Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-07_23-47


// Wrapper for: create, createWithResponse, get, getWithResponse, update, updateWithResponse, delete, deleteWithResponse, list, listWithResponse
// Reason: All CRUD and list operations for BlobContainer share a common set of parameters and patterns. This wrapper introduces an options parameter pattern for convenience and future extensibility, and provides overloads for common scenarios. Input validation is included for required parameters.

/**
 * Options for BlobContainer operations.
 */
public static class BlobContainerOptions {
    private final String subscriptionId;
    private final String resourceGroupName;
    private final String accountName;
    private final String containerName;
    private final String apiVersion;
    private BlobContainer blobContainer;
    private String maxpagesize;
    private String filter;
    private ListContainersInclude include;
    private RequestContext requestContext;

    public BlobContainerOptions(String subscriptionId, String resourceGroupName, String accountName, String containerName, String apiVersion) {
        if (subscriptionId == null || subscriptionId.isEmpty()) throw new IllegalArgumentException("subscriptionId is required");
        if (resourceGroupName == null || resourceGroupName.isEmpty()) throw new IllegalArgumentException("resourceGroupName is required");
        if (accountName == null || accountName.isEmpty()) throw new IllegalArgumentException("accountName is required");
        if (containerName == null || containerName.isEmpty()) throw new IllegalArgumentException("containerName is required");
        if (apiVersion == null || apiVersion.isEmpty()) throw new IllegalArgumentException("apiVersion is required");
        this.subscriptionId = subscriptionId;
        this.resourceGroupName = resourceGroupName;
        this.accountName = accountName;
        this.containerName = containerName;
        this.apiVersion = apiVersion;
    }

    public String getSubscriptionId() { return subscriptionId; }
    public String getResourceGroupName() { return resourceGroupName; }
    public String getAccountName() { return accountName; }
    public String getContainerName() { return containerName; }
    public String getApiVersion() { return apiVersion; }
    public BlobContainer getBlobContainer() { return blobContainer; }
    public BlobContainerOptions setBlobContainer(BlobContainer blobContainer) { this.blobContainer = blobContainer; return this; }
    public String getMaxpagesize() { return maxpagesize; }
    public BlobContainerOptions setMaxpagesize(String maxpagesize) { this.maxpagesize = maxpagesize; return this; }
    public String getFilter() { return filter; }
    public BlobContainerOptions setFilter(String filter) { this.filter = filter; return this; }
    public ListContainersInclude getInclude() { return include; }
    public BlobContainerOptions setInclude(ListContainersInclude include) { this.include = include; return this; }
    public RequestContext getRequestContext() { return requestContext; }
    public BlobContainerOptions setRequestContext(RequestContext requestContext) { this.requestContext = requestContext; return this; }
}

/**
 * Creates a new container or updates an existing one, depending on whether it exists.
 * Uses BlobContainerOptions for extensibility and input validation.
 */
public BlobContainer upsertContainer(BlobContainerOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    try {
        // Try to get the container; if not found, create it.
        get(options.getSubscriptionId(), options.getResourceGroupName(), options.getAccountName(), options.getContainerName(), options.getApiVersion());
        return update(options.getSubscriptionId(), options.getResourceGroupName(), options.getAccountName(), options.getContainerName(), options.getApiVersion(), options.getBlobContainer());
    } catch (HttpResponseException ex) {
        if (ex.getResponse().getStatusCode() == 404) {
            return create(options.getSubscriptionId(), options.getResourceGroupName(), options.getAccountName(), options.getContainerName(), options.getApiVersion(), options.getBlobContainer());
        }
        throw ex;
    }
}

/**
 * Gets properties of a specified container using BlobContainerOptions.
 */
public BlobContainer getContainer(BlobContainerOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    return get(options.getSubscriptionId(), options.getResourceGroupName(), options.getAccountName(), options.getContainerName(), options.getApiVersion());
}

/**
 * Deletes a specified container using BlobContainerOptions.
 */
public void deleteContainer(BlobContainerOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    delete(options.getSubscriptionId(), options.getResourceGroupName(), options.getAccountName(), options.getContainerName(), options.getApiVersion());
}

/**
 * Lists all containers for the given account using BlobContainerOptions.
 */
public ListContainerItems listContainers(BlobContainerOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    if (options.getMaxpagesize() != null || options.getFilter() != null || options.getInclude() != null || options.getRequestContext() != null) {
        // Use maximal overload if any advanced options are set
        return listWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getApiVersion(),
            options.getMaxpagesize(),
            options.getFilter(),
            options.getInclude(),
            options.getRequestContext()
        ).getValue();
    } else {
        return list(options.getSubscriptionId(), options.getResourceGroupName(), options.getAccountName(), options.getApiVersion());
    }
}// Wrapper for setLegalHold, setLegalHoldWithResponse, clearLegalHold, clearLegalHoldWithResponse
// Reason: These methods share identical parameter patterns and functionality (setting or clearing legal hold tags), differing only in the operation (set vs clear) and whether the full HTTP response is returned. Wrapping them together provides a single entry point for managing legal holds, reducing boilerplate and improving discoverability. Input validation is added for required parameters.

    /**
     * Applies or clears legal hold tags on a blob container.
     *
     * @param subscriptionId The subscriptionId parameter. Cannot be null or empty.
     * @param resourceGroupName The resourceGroupName parameter. Cannot be null or empty.
     * @param accountName The accountName parameter. Cannot be null or empty.
     * @param containerName The containerName parameter. Cannot be null or empty.
     * @param apiVersion The apiVersion parameter. Cannot be null or empty.
     * @param legalHold The legalHold parameter. Cannot be null.
     * @param setHold If true, sets the legal hold; if false, clears the legal hold.
     * @param withResponse If true, returns the full HTTP response; if false, returns only the LegalHold entity.
     * @param requestContext Optional. The context to configure the HTTP request before HTTP client sends it. May be null if withResponse is false.
     * @return The LegalHold property of a blob container, or Response&lt;LegalHold&gt; if withResponse is true.
     * @throws IllegalArgumentException if required parameters are null or empty.
     */
    public Object manageLegalHold(
        String subscriptionId,
        String resourceGroupName,
        String accountName,
        String containerName,
        String apiVersion,
        LegalHold legalHold,
        boolean setHold,
        boolean withResponse,
        RequestContext requestContext
    ) {
        // Input validation for required parameters
        if (subscriptionId == null || subscriptionId.isEmpty()) {
            throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
        }
        if (resourceGroupName == null || resourceGroupName.isEmpty()) {
            throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
        }
        if (accountName == null || accountName.isEmpty()) {
            throw new IllegalArgumentException("accountName cannot be null or empty.");
        }
        if (containerName == null || containerName.isEmpty()) {
            throw new IllegalArgumentException("containerName cannot be null or empty.");
        }
        if (apiVersion == null || apiVersion.isEmpty()) {
            throw new IllegalArgumentException("apiVersion cannot be null or empty.");
        }
        if (legalHold == null) {
            throw new IllegalArgumentException("legalHold cannot be null.");
        }

        if (setHold) {
            if (withResponse) {
                return this.setLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold, requestContext);
            } else {
                return this.setLegalHold(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold);
            }
        } else {
            if (withResponse) {
                return this.clearLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold, requestContext);
            } else {
                return this.clearLegalHold(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold);
            }
        }
    }// Wrapper for Immutability Policy operations
// Methods wrapped: 
//   - createOrUpdateImmutabilityPolicy
//   - createOrUpdateImmutabilityPolicyWithResponse
//   - getImmutabilityPolicy
//   - getImmutabilityPolicyWithResponse
//   - lockImmutabilityPolicy
//   - lockImmutabilityPolicyWithResponse
//   - extendImmutabilityPolicy
//   - extendImmutabilityPolicyWithResponse
//   - deleteImmutabilityPolicy
//   - deleteImmutabilityPolicyWithResponse
// Reason: These methods follow a consistent pattern for CRUD operations on ImmutabilityPolicy. Wrapping them using an options parameter pattern improves developer experience by reducing parameter overloads and simplifying the API surface, in line with Azure SDK guidelines.

public class ImmutabilityPolicyOptions {
    private final String subscriptionId;
    private final String resourceGroupName;
    private final String accountName;
    private final String containerName;
    private final String apiVersion;
    private String ifMatch;
    private ImmutabilityPolicy parameters;
    private RequestContext requestContext;

    public ImmutabilityPolicyOptions(String subscriptionId, String resourceGroupName, String accountName, String containerName, String apiVersion) {
        if (subscriptionId == null || resourceGroupName == null || accountName == null || containerName == null || apiVersion == null) {
            throw new IllegalArgumentException("Required parameters must not be null.");
        }
        this.subscriptionId = subscriptionId;
        this.resourceGroupName = resourceGroupName;
        this.accountName = accountName;
        this.containerName = containerName;
        this.apiVersion = apiVersion;
    }

    public String getSubscriptionId() { return subscriptionId; }
    public String getResourceGroupName() { return resourceGroupName; }
    public String getAccountName() { return accountName; }
    public String getContainerName() { return containerName; }
    public String getApiVersion() { return apiVersion; }

    public String getIfMatch() { return ifMatch; }
    public ImmutabilityPolicyOptions setIfMatch(String ifMatch) { this.ifMatch = ifMatch; return this; }

    public ImmutabilityPolicy getParameters() { return parameters; }
    public ImmutabilityPolicyOptions setParameters(ImmutabilityPolicy parameters) { this.parameters = parameters; return this; }

    public RequestContext getRequestContext() { return requestContext; }
    public ImmutabilityPolicyOptions setRequestContext(RequestContext requestContext) { this.requestContext = requestContext; return this; }
}

// Convenience wrapper methods

public ImmutabilityPolicy createOrUpdateImmutabilityPolicy(ImmutabilityPolicyOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    if (options.getIfMatch() != null && options.getParameters() != null && options.getRequestContext() != null) {
        // Maximal overload with all parameters
        return this.serviceClient.createOrUpdateImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getParameters(),
            options.getRequestContext()
        ).getValue();
    } else {
        // Minimal overload
        return this.serviceClient.createOrUpdateImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion()
        );
    }
}

public ImmutabilityPolicy getImmutabilityPolicy(ImmutabilityPolicyOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    if (options.getIfMatch() != null && options.getRequestContext() != null) {
        return this.serviceClient.getImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getRequestContext()
        ).getValue();
    } else {
        return this.serviceClient.getImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion()
        );
    }
}

public ImmutabilityPolicy lockImmutabilityPolicy(ImmutabilityPolicyOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    if (options.getIfMatch() != null && options.getRequestContext() != null) {
        return this.serviceClient.lockImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getRequestContext()
        ).getValue();
    } else if (options.getIfMatch() != null) {
        return this.serviceClient.lockImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch()
        );
    } else {
        throw new IllegalArgumentException("ifMatch is required for lock operation.");
    }
}

public ImmutabilityPolicy extendImmutabilityPolicy(ImmutabilityPolicyOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    if (options.getIfMatch() != null && options.getParameters() != null && options.getRequestContext() != null) {
        return this.serviceClient.extendImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getParameters(),
            options.getRequestContext()
        ).getValue();
    } else if (options.getIfMatch() != null) {
        return this.serviceClient.extendImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch()
        );
    } else {
        throw new IllegalArgumentException("ifMatch is required for extend operation.");
    }
}

public ImmutabilityPolicy deleteImmutabilityPolicy(ImmutabilityPolicyOptions options) {
    if (options == null) throw new IllegalArgumentException("options cannot be null");
    if (options.getIfMatch() != null && options.getRequestContext() != null) {
        return this.serviceClient.deleteImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getRequestContext()
        ).getValue();
    } else if (options.getIfMatch() != null) {
        return this.serviceClient.deleteImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch()
        );
    } else {
        throw new IllegalArgumentException("ifMatch is required for delete operation.");
    }
}