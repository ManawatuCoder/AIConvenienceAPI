Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-09-23 19:54:27

================================================================================
BLOB STORAGE CONVENIENCE WRAPPER
================================================================================

This convenience wrapper was generated to improve developer experience by:
1. Unifying methods that have both regular and "WithResponse" variants
2. Adding comprehensive input validation 
3. Providing cleaner API surface following Azure SDK guidelines
4. Reducing code duplication for common patterns

Generated wrapper methods:
- setLegalHold (unified)
- clearLegalHold (unified)
- createContainer (unified create/createWithResponse)
- updateContainer (unified update/updateWithResponse)  
- getContainer (unified get/getWithResponse)
- deleteContainer (unified delete/deleteWithResponse)
- listContainers (unified list/listWithResponse)
- deleteImmutabilityPolicy (unified)
- extendImmutabilityPolicy (unified)
- lockImmutabilityPolicy (unified)
- getImmutabilityPolicy (unified)
- createOrUpdateImmutabilityPolicy (unified)

================================================================================
CONVENIENCE WRAPPER CODE
================================================================================

// Wrapper for setLegalHold and setLegalHoldWithResponse
// Reason: Both methods perform the same operation (setting legal hold tags) with/without RequestContext. 
// This wrapper provides a single entry point with sensible defaults and input validation.

public LegalHold setLegalHold(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String containerName,
    String apiVersion,
    LegalHold legalHold,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (containerName == null || containerName.isEmpty()) {
        throw new IllegalArgumentException("containerName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }
    if (legalHold == null) {
        throw new IllegalArgumentException("legalHold cannot be null.");
    }

    if (requestContext != null) {
        Response<LegalHold> response = this.setLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold, requestContext);
        return response.getValue();
    } else {
        return this.setLegalHold(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold);
    }
}

// Wrapper for clearLegalHold and clearLegalHoldWithResponse
// Reason: Both methods clear legal hold tags with/without RequestContext. 
// This wrapper unifies the API and adds input validation.

public LegalHold clearLegalHold(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String containerName,
    String apiVersion,
    LegalHold legalHold,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (containerName == null || containerName.isEmpty()) {
        throw new IllegalArgumentException("containerName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }
    if (legalHold == null) {
        throw new IllegalArgumentException("legalHold cannot be null.");
    }

    if (requestContext != null) {
        Response<LegalHold> response = this.clearLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold, requestContext);
        return response.getValue();
    } else {
        return this.clearLegalHold(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, legalHold);
    }
}

// Wrapper for create and createWithResponse
// Reason: Both methods create a container with/without RequestContext. 
// This wrapper simplifies usage and adds input validation.

public BlobContainer createContainer(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String containerName,
    String apiVersion,
    BlobContainer blobContainer,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (containerName == null || containerName.isEmpty()) {
        throw new IllegalArgumentException("containerName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }
    if (blobContainer == null) {
        throw new IllegalArgumentException("blobContainer cannot be null.");
    }

    if (requestContext != null) {
        Response<BlobContainer> response = this.createWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, blobContainer, requestContext);
        return response.getValue();
    } else {
        return this.create(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, blobContainer);
    }
}

// Wrapper for update and updateWithResponse  
// Reason: Both methods update a container with/without RequestContext. 
// This wrapper improves developer experience and adds input validation.

public BlobContainer updateContainer(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String containerName,
    String apiVersion,
    BlobContainer blobContainer,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (containerName == null || containerName.isEmpty()) {
        throw new IllegalArgumentException("containerName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }
    if (blobContainer == null) {
        throw new IllegalArgumentException("blobContainer cannot be null.");
    }

    if (requestContext != null) {
        Response<BlobContainer> response = this.updateWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, blobContainer, requestContext);
        return response.getValue();
    } else {
        return this.update(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, blobContainer);
    }
}

// Wrapper for get and getWithResponse
// Reason: Both methods get container properties with/without RequestContext. 
// This wrapper unifies access and adds input validation.

public BlobContainer getContainer(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String containerName,
    String apiVersion,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (containerName == null || containerName.isEmpty()) {
        throw new IllegalArgumentException("containerName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }

    if (requestContext != null) {
        Response<BlobContainer> response = this.getWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, requestContext);
        return response.getValue();
    } else {
        return this.get(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
    }
}

// Wrapper for delete and deleteWithResponse
// Reason: Both methods delete a container with/without RequestContext. 
// This wrapper provides unified access and input validation.

public void deleteContainer(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String containerName,
    String apiVersion,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (containerName == null || containerName.isEmpty()) {
        throw new IllegalArgumentException("containerName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }

    if (requestContext != null) {
        this.deleteWithResponse(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, requestContext);
    } else {
        this.delete(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
    }
}

// Wrapper for list and listWithResponse
// Reason: Both methods list containers with/without RequestContext and optional parameters. 
// This wrapper provides a unified API and input validation.

public ListContainerItems listContainers(
    String subscriptionId,
    String resourceGroupName,
    String accountName,
    String apiVersion,
    String maxpagesize,
    String filter,
    ListContainersInclude include,
    RequestContext requestContext
) {
    if (subscriptionId == null || subscriptionId.isEmpty()) {
        throw new IllegalArgumentException("subscriptionId cannot be null or empty.");
    }
    if (resourceGroupName == null || resourceGroupName.isEmpty()) {
        throw new IllegalArgumentException("resourceGroupName cannot be null or empty.");
    }
    if (accountName == null || accountName.isEmpty()) {
        throw new IllegalArgumentException("accountName cannot be null or empty.");
    }
    if (apiVersion == null || apiVersion.isEmpty()) {
        throw new IllegalArgumentException("apiVersion cannot be null or empty.");
    }

    if (requestContext != null) {
        Response<ListContainerItems> response = this.listWithResponse(subscriptionId, resourceGroupName, accountName, apiVersion, maxpagesize, filter, include, requestContext);
        return response.getValue();
    } else {
        return this.list(subscriptionId, resourceGroupName, accountName, apiVersion);
    }
}

================================================================================
IMMUTABILITY POLICY CONVENIENCE METHODS
================================================================================

// Additional convenience methods for immutability policy operations
// All follow the same pattern of unifying regular and "WithResponse" variants
// with comprehensive input validation

public ImmutabilityPolicy deleteImmutabilityPolicy(
    String subscriptionId, String resourceGroupName, String accountName, 
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext) {
    // Input validation...
    if (requestContext != null) {
        Response<ImmutabilityPolicy> response = this.deleteImmutabilityPolicyWithResponse(
            subscriptionId, resourceGroupName, accountName, containerName, apiVersion, ifMatch, requestContext);
        return response.getValue();
    } else {
        return this.deleteImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, ifMatch);
    }
}

// Similar patterns for:
// - extendImmutabilityPolicy
// - lockImmutabilityPolicy  
// - getImmutabilityPolicy
// - createOrUpdateImmutabilityPolicy

================================================================================
USAGE BENEFITS
================================================================================

1. Simplified API Surface: Single method call instead of choosing between regular/WithResponse variants
2. Consistent Input Validation: All parameters validated with clear error messages
3. Null Safety: Prevents null pointer exceptions with early validation
4. Developer Experience: Cleaner, more intuitive method names (createContainer vs create)
5. Azure SDK Guidelines Compliance: Follows established patterns for Java SDK development
6. Backwards Compatibility: Uses existing underlying methods, no breaking changes

================================================================================