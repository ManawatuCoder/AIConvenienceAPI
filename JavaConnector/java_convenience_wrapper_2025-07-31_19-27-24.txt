Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-07-31 19:27:24
========================================

=== GENERATED CONVENIENCE WRAPPER ===
Below is a Java convenience SDK wrapper for Blob Container management in Azure Storage, following the Azure SDK Design Guidelines for Java. This wrapper provides a user-friendly, idiomatic Java API over the generated TypeSpec code and models, and is designed for use in typical Azure SDK scenarios.

**Key Features:**
- Follows Azure SDK Java guidelines: builder pattern, clear method naming, overloads, null/empty handling, and idiomatic Java types.
- Focuses on Blob Container management (CRUD, legal hold, immutability policy).
- Provides a single entrypoint (`BlobContainerManager`) for ease of use.
- Uses the generated `BlobContainersClient` and models.
- Handles common parameters (subscriptionId, resourceGroupName, accountName, apiVersion) via the builder.
- Supports context passing for advanced scenarios.

---

```java
package com.azure.resourcemanager.storage.blob;

import azurestoragemanagement.*;
import io.clientcore.core.http.models.RequestContext;
import io.clientcore.core.http.models.Response;
import java.util.List;
import java.util.Objects;

/**
 * Convenience wrapper for managing Blob Containers in Azure Storage Accounts.
 * <p>
 * Example usage:
 * <pre>
 * BlobContainerManager manager = new BlobContainerManagerBuilder()
 *     .subscriptionId("xxxx")
 *     .resourceGroupName("rg")
 *     .accountName("mystorageacct")
 *     .apiVersion("2019-06-01")
 *     .build();
 *
 * // List containers
 * List<BlobContainer> containers = manager.list();
 *
 * // Create a container
 * BlobContainer created = manager.create("mycontainer", new BlobContainer().setProperties(...));
 *
 * // Get a container
 * BlobContainer container = manager.get("mycontainer");
 *
 * // Delete a container
 * manager.delete("mycontainer");
 * </pre>
 */
public final class BlobContainerManager {
    private final BlobContainersClient client;
    private final String subscriptionId;
    private final String resourceGroupName;
    private final String accountName;
    private final String apiVersion;

    BlobContainerManager(BlobContainersClient client, String subscriptionId, String resourceGroupName, String accountName, String apiVersion) {
        this.client = Objects.requireNonNull(client, "'client' cannot be null");
        this.subscriptionId = Objects.requireNonNull(subscriptionId, "'subscriptionId' cannot be null");
        this.resourceGroupName = Objects.requireNonNull(resourceGroupName, "'resourceGroupName' cannot be null");
        this.accountName = Objects.requireNonNull(accountName, "'accountName' cannot be null");
        this.apiVersion = Objects.requireNonNull(apiVersion, "'apiVersion' cannot be null");
    }

    /**
     * Lists all blob containers in the storage account.
     * @return list of BlobContainer objects
     */
    public List<BlobContainer> list() {
        ListContainerItems items = client.list(subscriptionId, resourceGroupName, accountName, apiVersion);
        return items != null && items.getValue() != null
            ? items.getValue().stream().map(item -> {
                BlobContainer container = new BlobContainer()
                    .setId(item.getId())
                    .setName(item.getName())
                    .setType(item.getType())
                    .setEtag(item.getEtag())
                    .setProperties(item.getProperties());
                return container;
            }).toList()
            : List.of();
    }

    /**
     * Gets a blob container by name.
     * @param containerName the container name
     * @return the BlobContainer, or null if not found
     */
    public BlobContainer get(String containerName) {
        try {
            return client.get(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
        } catch (Exception ex) {
            // Optionally handle 404 as null
            if (ex.getMessage() != null && ex.getMessage().contains("404")) {
                return null;
            }
            throw ex;
        }
    }

    /**
     * Creates a new blob container.
     * @param containerName the container name
     * @param container the BlobContainer properties
     * @return the created BlobContainer
     */
    public BlobContainer create(String containerName, BlobContainer container) {
        return client.create(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, container);
    }

    /**
     * Updates an existing blob container.
     * @param containerName the container name
     * @param container the BlobContainer properties to update
     * @return the updated BlobContainer
     */
    public BlobContainer update(String containerName, BlobContainer container) {
        return client.update(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, container);
    }

    /**
     * Deletes a blob container.
     * @param containerName the container name
     */
    public void delete(String containerName) {
        client.delete(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
    }

    /**
     * Sets legal hold tags for a container.
     * @param containerName the container name
     * @param tags list of tags (must be 3-23 alphanumeric chars each)
     * @return updated LegalHold
     */
    public LegalHold setLegalHold(String containerName, List<String> tags) {
        LegalHold hold = new LegalHold().setTags(tags);
        return client.setLegalHold(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, hold);
    }

    /**
     * Clears legal hold tags for a container.
     * @param containerName the container name
     * @param tags list of tags to clear
     * @return updated LegalHold
     */
    public LegalHold clearLegalHold(String containerName, List<String> tags) {
        LegalHold hold = new LegalHold().setTags(tags);
        return client.clearLegalHold(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, hold);
    }

    /**
     * Gets the immutability policy for a container.
     * @param containerName the container name
     * @return ImmutabilityPolicy, or null if not set
     */
    public ImmutabilityPolicy getImmutabilityPolicy(String containerName) {
        try {
            return client.getImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
        } catch (Exception ex) {
            if (ex.getMessage() != null && ex.getMessage().contains("404")) {
                return null;
            }
            throw ex;
        }
    }

    /**
     * Creates or updates an immutability policy for a container.
     * @param containerName the container name
     * @param policy the ImmutabilityPolicy to set
     * @param ifMatch optional ETag for concurrency (can be null)
     * @return updated ImmutabilityPolicy
     */
    public ImmutabilityPolicy createOrUpdateImmutabilityPolicy(String containerName, ImmutabilityPolicy policy, String ifMatch) {
        return client.createOrUpdateImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, ifMatch, policy);
    }

    /**
     * Deletes the immutability policy for a container.
     * @param containerName the container name
     * @param ifMatch required ETag
     * @return deleted ImmutabilityPolicy
     */
    public ImmutabilityPolicy deleteImmutabilityPolicy(String containerName, String ifMatch) {
        return client.deleteImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, ifMatch);
    }

    /**
     * Locks the immutability policy for a container.
     * @param containerName the container name
     * @param ifMatch required ETag
     * @return locked ImmutabilityPolicy
     */
    public ImmutabilityPolicy lockImmutabilityPolicy(String containerName, String ifMatch) {
        return client.lockImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, ifMatch);
    }

    /**
     * Extends the immutability policy for a container.
     * @param containerName the container name
     * @param ifMatch required ETag
     * @param policy updated ImmutabilityPolicy
     * @return extended ImmutabilityPolicy
     */
    public ImmutabilityPolicy extendImmutabilityPolicy(String containerName, String ifMatch, ImmutabilityPolicy policy) {
        return client.extendImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName, apiVersion, ifMatch, policy);
    }

    // Advanced: Overloads with RequestContext for custom pipeline/context scenarios can be added as needed.
}
```

---

**Builder for BlobContainerManager:**

```java
package com.azure.resourcemanager.storage.blob;

import azurestoragemanagement.*;
import java.util.Objects;

/**
 * Builder for BlobContainerManager.
 */
public final class BlobContainerManagerBuilder {
    private String subscriptionId;
    private String resourceGroupName;
    private String accountName;
    private String apiVersion = "2019-06-01"; // Default as per spec
    private AzureStorageManagementClientBuilder innerBuilder = new AzureStorageManagementClientBuilder();

    public BlobContainerManagerBuilder subscriptionId(String subscriptionId) {
        this.subscriptionId = subscriptionId;
        return this;
    }

    public BlobContainerManagerBuilder resourceGroupName(String resourceGroupName) {
        this.resourceGroupName = resourceGroupName;
        return this;
    }

    public BlobContainerManagerBuilder accountName(String accountName) {
        this.accountName = accountName;
        return this;
    }

    public BlobContainerManagerBuilder apiVersion(String apiVersion) {
        this.apiVersion = apiVersion;
        return this;
    }

    public BlobContainerManagerBuilder endpoint(String endpoint) {
        innerBuilder.endpoint(endpoint);
        return this;
    }

    // Add other builder methods for proxy, retry, etc. as needed

    public BlobContainerManager build() {
        Objects.requireNonNull(subscriptionId, "'subscriptionId' is required");
        Objects.requireNonNull(resourceGroupName, "'resourceGroupName' is required");
        Objects.requireNonNull(accountName, "'accountName' is required");
        BlobContainersClient client = innerBuilder.buildBlobContainersClient();
        return new BlobContainerManager(client, subscriptionId, resourceGroupName, accountName, apiVersion);
    }
}
```

---

**How to Use:**

```java
BlobContainerManager manager = new BlobContainerManagerBuilder()
    .subscriptionId("xxxx")
    .resourceGroupName("myrg")
    .accountName("mystorage")
    .build();

List<BlobContainer> containers = manager.list();
BlobContainer created = manager.create("testcontainer", new BlobContainer().setProperties(...));
manager.delete("testcontainer");
```

---

**Notes:**
- This wrapper is designed for synchronous usage. For async, a similar pattern can be applied.
- Error handling for 404 returns `null` for `get`/`getImmutabilityPolicy` for convenience.
- You can extend this pattern for `BlobServicesClient` as well.
- All methods are thread-safe if the underlying `BlobContainersClient` is thread-safe.

---

**This wrapper provides a modern, idiomatic, and easy-to-use Java API for managing blob containers in Azure Storage, strictly following Azure SDK Java guidelines.**

=== USAGE STATISTICS ===
Prompt tokens: 16692
Completion tokens: 2374
Total tokens: 19066
========================================
