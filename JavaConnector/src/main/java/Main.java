import codegenFragmenter.ChunkLinker;
import codegenFragmenter.CodegenFragmenter;
import com.azure.ai.openai.OpenAIClient;
import com.azure.ai.openai.OpenAIClientBuilder;
import com.azure.ai.openai.models.*;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.util.Configuration;
import com.google.gson.*;
import guidelinesFragmentation.GuidelineParser;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class Main {
  private static final Properties props = new Properties();
  // Azure OpenAI configuration constants
  private static final String DEPLOYMENT_NAME = "gpt-4.1";

  // Loads config properties
  static Properties loadConfigProperties(Path configFile) {
    try (InputStream configInput = Files.newInputStream(configFile)) {
      props.load(configInput);

      if (props.getProperty("AZURE_OPENAI_KEY") == null || props.getProperty("AZURE_OPENAI_KEY").isEmpty()) {
        throw new IllegalStateException("AZURE_OPENAI_KEY is missing in config.properties");
      }
      if (props.getProperty("AZURE_OPENAI_ENDPOINT") == null || props.getProperty("AZURE_OPENAI_ENDPOINT").isEmpty()) {
        throw new IllegalStateException("AZURE_OPENAI_ENDPOINT is missing in config.properties");
      }

      return props;
    } catch (Exception e) {
      throw new RuntimeException("Unable to find config.properties", e);
    }
  }

  // Creates and configures the Azure OpenAI client
  static OpenAIClient createOpenAIClient() {
    String endpoint =
        Configuration.getGlobalConfiguration().get("AZURE_OPENAI_ENDPOINT", props.getProperty("AZURE_OPENAI_ENDPOINT"));
    String apiKey =
        Configuration.getGlobalConfiguration().get("AZURE_OPENAI_KEY", props.getProperty("AZURE_OPENAI_KEY"));
    return new OpenAIClientBuilder()
        .endpoint(endpoint)
        .credential(new AzureKeyCredential(apiKey))
        .buildClient();
  }

  private static String sendChunks(OpenAIClient client, String prompt) throws IOException {

    List<ChatRequestMessage> messages = new ArrayList<>();

    // Add system prompt
    String systemPrompt = Files.readString(Path.of("../Prompts/MethodsGuidelinesPrompt.txt"));
    messages.add(new ChatRequestSystemMessage(systemPrompt));

    // Send all content including InputSpecs, TypeSpec, and generated code
    messages.add(new ChatRequestUserMessage(prompt));

    // Chat settings for the AI model
    ChatCompletionsOptions options =
        new ChatCompletionsOptions(messages)
            .setMaxTokens(4000) // Increase max tokens for better output
            .setTemperature(0.3) // Lower temperature for more analytical response
            .setTopP(0.95);

    try {
      ChatCompletions chatCompletions = client.getChatCompletions(DEPLOYMENT_NAME, options);
      ChatChoice choice = chatCompletions.getChoices().get(0);
      String aiResponse = choice.getMessage().getContent();
      return aiResponse;

    } catch (Exception e) {
      System.err.println("Error during convenience wrapper generation: " + e.getMessage());
      e.printStackTrace();
    }
    return null;
  }

  private static void prepareFragments(OpenAIClient client) throws Exception {
    CodegenFragmenter fragmenter = new CodegenFragmenter();
    ChunkLinker linker = new ChunkLinker();
    List<List<String>> linked = List.of();
    GuidelineParser parser = new GuidelineParser();

    // Create a timestamped filename
    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm"));
    String filename = String.format("../WrapperOutputs/java_convenience_wrapper_%s.txt", timestamp);
    Path outputPath = Paths.get(filename);
    StringBuilder reportBuilder = new StringBuilder();
    reportBuilder.append("Java Convenience Wrapper Generated by Azure OpenAI\n");
    reportBuilder
        .append("Generated: ")
        .append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")))
        .append("\n");

    String guidelineString =
        Files.readString(
            Path.of(parser.parse("https://azure.github.io/azure-sdk/java_introduction.html")));
    JsonArray guidelineArray = JsonParser.parseString(guidelineString).getAsJsonArray();
    String headings = "";
    String codeHeader = "";
    String output = "";
    String methods = "";
    String prompt = "";

    for (JsonElement element : guidelineArray) {
      headings += element.getAsJsonObject().get("heading").getAsString() + "\n";
    }
    Map<String, String> newMap = null;
    try {
      newMap =
          fragmenter.fragment(
              new File(
                  "..\\TypeSpec_Conversion\\tsp-output\\clients\\java\\src\\main\\java\\azurestoragemanagement\\BlobContainersClient.java"));
      codeHeader = newMap.get("Header");
      newMap.remove("Header");
      methods = newMap.keySet().toString();
      linked = linker.link(newMap);

    } catch (IOException e) {
      e.printStackTrace();
    }

    // ########################################
    // First Prompt (Flags Method Names & Guidelines from List)
    // ########################################
    prompt = Files.readString(Path.of("../Prompts/MethodsGuidelinesPrompt.txt"));
    prompt = prompt.replace("{methodNames}", methods);
    prompt = prompt.replace("{guidelines}", headings);

    // Call the AI, returns
    String outputMethodsGuidelines = sendChunks(client, prompt);

    // Appends prompt + output to file
    // TODO: Implement logging to format the output better
    reportBuilder.append(
        "\n\n===========================================================================================\n");
    reportBuilder.append("Prompt 1\n");
    reportBuilder.append(
        "===========================================================================================\n\n\n");
    reportBuilder.append(prompt);
    reportBuilder.append(
        "\n===========================================================================================\n\n\n\n");
    reportBuilder.append(
        "\n===========================================================================================\n");
    reportBuilder.append("Step 1 Output: Method and Guideline request\n");
    reportBuilder.append(
        "===========================================================================================\n\n");
    reportBuilder.append(outputMethodsGuidelines);
    reportBuilder.append(
        "\n===========================================================================================\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");

    // Fallback for when the AI cannot find improvements
    if (outputMethodsGuidelines.toLowerCase().equals("no")) {
      System.out.println("No patterns found in code. Stopping all further operations");
      return;
    }

    // Format the output to be used for next prompt
    JsonObject JSONMethodsGuidelines =
        JsonParser.parseString(outputMethodsGuidelines).getAsJsonObject();

    JsonArray methodsArray = JSONMethodsGuidelines.getAsJsonArray("methods");
    JsonArray guidelineHeaderArray = JSONMethodsGuidelines.getAsJsonArray("guidelines");

    Map<String, String> flaggedMethods = new HashMap<>();
    Map<String, String> flaggedGuidelines = new HashMap<>();

    // Attach code to each flagged method
    for (JsonElement e : methodsArray) {
      assert newMap != null;
      String methodName = e.getAsString().trim();
      String code = newMap.get(methodName + "(");

      // If method name exists in map
      if (code != null) {
        // Attach code to method name entry
        flaggedMethods.put(
            methodName,
            newMap.get(methodName + "(")); // The '(' is on all map entry names for pattern matching
      }
    }

    // Attach guideline to guideline header
    for (JsonElement flaggedGuideline : guidelineHeaderArray) {
      String flaggedGuidelineHeader = flaggedGuideline.getAsString().trim();

      for (JsonElement guideline : guidelineArray) {
        String heading = guideline.getAsJsonObject().get("heading").getAsString().trim();

        if (heading.equals(flaggedGuidelineHeader)) {
          String guidelineContent = guideline.getAsJsonObject().get("content").getAsString().trim();
          flaggedGuidelines.put(heading, guidelineContent);
          break;
        }
      }
    }

    // ########################################
    // Second (Main) Prompt (Generates wrapper from flagged code and guidelines)
    // ########################################
    String selectedCode = "";
    String selectedGuidelines = "";
    prompt = Files.readString(Path.of("../Prompts/MainPrompt.txt"));

    for (Map.Entry<String, String> method : flaggedMethods.entrySet()) {
      selectedCode += method.getValue() + "\n";
    }
    for (Map.Entry<String, String> guideline : flaggedGuidelines.entrySet()) {
      selectedGuidelines += guideline.getKey() + "\n" + guideline.getValue() + "\n\n";
    }

    prompt = prompt.replace("{code}", selectedCode);
    prompt = prompt.replace("{guidelines}", selectedGuidelines);

    String outputWrapper = sendChunks(client, prompt);
    reportBuilder.append(
        "===========================================================================================\n");
    reportBuilder.append("Prompt 2\n");
    reportBuilder.append(
        "===========================================================================================\n\n");
    reportBuilder.append(prompt);
    reportBuilder.append(
        "\n===========================================================================================\n\n\n\n\n");

    // Fallback for when the AI cannot find improvements
    if (outputWrapper.toLowerCase().equals("no")) {
      System.out.println("No patterns found in code. Stopping all further operations");
      return;
    }
    reportBuilder.append(
        "===========================================================================================\n");
    reportBuilder.append("Step 2 Output: Generated Wrapper\n");
    reportBuilder.append(
        "===========================================================================================\n");
    reportBuilder.append(outputWrapper);
    reportBuilder.append(
        "\n===========================================================================================\n\n");

    // Write to file
    Files.writeString(
        outputPath, reportBuilder.toString(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);

    System.out.println("Java Wrapper saved to file");
  }

  public static void main(String[] args) throws Exception {
    try {
      loadConfigProperties(Paths.get("config.properties"));
      OpenAIClient client = createOpenAIClient();
      prepareFragments(client);

    } catch (ClientAuthenticationException e) {
      System.err.println("Authentication failed: " + e.getMessage());
      System.err.println("Please check your API key and endpoint.");
    } catch (IOException e) {
      System.err.println("File reading error: " + e.getMessage());
      e.printStackTrace();
    } catch (Exception e) {
      System.err.println("Error occurred: " + e.getMessage());
      e.printStackTrace();
    }
  }
}
