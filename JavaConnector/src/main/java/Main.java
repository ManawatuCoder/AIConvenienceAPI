
// Main class for generating Java convenience wrappers using Azure OpenAI
import codegenFragmenter.CodegenFragmenter;
import codegenFragmenter.FragmentLinker;

// Imports for Azure OpenAI SDK
import com.azure.ai.openai.OpenAIClient;
import com.azure.ai.openai.OpenAIClientBuilder;
import com.azure.ai.openai.models.*;
import com.azure.core.credential.AzureKeyCredential;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.util.Configuration;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.javaparser.utils.Log;
import com.google.gson.*;
import guidelinesFragmentation.GuidelineParser;

// Imports for MCP server
import io.modelcontextprotocol.server.McpServer;
import io.modelcontextprotocol.server.McpServerFeatures;
import io.modelcontextprotocol.server.transport.StdioServerTransportProvider;
import io.modelcontextprotocol.spec.McpSchema;

// Imports for file handling and utilities
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

public class Main {
  private static final Properties prop = new Properties();
  // Azure OpenAI configuration constants
  private static String AZURE_OPENAI_ENDPOINT;
  private static String AZURE_OPENAI_KEY;
  private static final String DEPLOYMENT_NAME = "gpt-4.1";

  // Loads config properties
  private static void loadConfigProperties() {
    try (InputStream configInput = Files
        .newInputStream(Paths.get("D:\\UpdatedMCP\\AIConvenienceAPI\\JavaConnector\\config.properties"))) {
      prop.load(configInput);

      AZURE_OPENAI_ENDPOINT = prop.getProperty("AZURE_OPENAI_ENDPOINT");
      AZURE_OPENAI_KEY = prop.getProperty("AZURE_OPENAI_KEY");

      if (AZURE_OPENAI_KEY == null || AZURE_OPENAI_KEY.isEmpty()) {
        throw new IllegalStateException("AZURE_OPENAI_KEY is missing in config.properties");
      }
      if (AZURE_OPENAI_ENDPOINT == null || AZURE_OPENAI_ENDPOINT.isEmpty()) {
        throw new IllegalStateException("AZURE_OPENAI_ENDPOINT is missing in config.properties");
      }
    } catch (Exception e) {
      throw new RuntimeException("Unable to find config.properties", e);
    }
  }

  // Creates and configures the Azure OpenAI client
  private static OpenAIClient createOpenAIClient() {
    String endpoint = Configuration.getGlobalConfiguration().get("AZURE_OPENAI_ENDPOINT", AZURE_OPENAI_ENDPOINT);
    String apiKey = Configuration.getGlobalConfiguration().get("AZURE_OPENAI_KEY", AZURE_OPENAI_KEY);
    return new OpenAIClientBuilder()
        .endpoint(endpoint)
        .credential(new AzureKeyCredential(apiKey))
        .buildClient();
  }

  private static String sendFragments(OpenAIClient client, String prompt) throws IOException {

    List<ChatRequestMessage> messages = new ArrayList<>();

    // Add system prompt
    String systemPrompt = Files
        .readString(Path.of("D:\\UpdatedMCP\\AIConvenienceAPI\\Prompts\\MethodsGuidelinesPrompt.txt"));
    messages.add(new ChatRequestSystemMessage(systemPrompt));

    // Send all content including InputSpecs, TypeSpec, and generated code
    messages.add(new ChatRequestUserMessage(prompt));

    // Chat settings for the AI model
    ChatCompletionsOptions options = new ChatCompletionsOptions(messages)
        .setMaxTokens(4000) // Increase max tokens for better output
        .setTemperature(0.3) // Lower temperature for more analytical response
        .setTopP(0.95);

    try {
      ChatCompletions chatCompletions = client.getChatCompletions(DEPLOYMENT_NAME, options);
      ChatChoice choice = chatCompletions.getChoices().get(0);
      String aiResponse = choice.getMessage().getContent();
      return aiResponse;

    } catch (Exception e) {
      System.err.println("Error during convenience wrapper generation: " + e.getMessage());
      e.printStackTrace();
    }
    return null;
  }

  private static String prepareFragments(OpenAIClient client) throws Exception {
    CodegenFragmenter fragmenter = new CodegenFragmenter();
    FragmentLinker linker = new FragmentLinker();
    List<List<String>> linked = List.of();
    GuidelineParser parser = new GuidelineParser();

    // Create a timestamped filename
    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm"));
    String filename = String.format("D:\\UpdatedMCP\\AIConvenienceAPI\\WrapperOutputs\\java_convenience_wrapper_%s.txt",
        timestamp);
    Path outputPath = Paths.get(filename);
    StringBuilder reportBuilder = new StringBuilder();
    reportBuilder.append("Java Convenience Wrapper Generated by Azure OpenAI\n");
    reportBuilder
        .append("Generated: ")
        .append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")))
        .append("\n");

    String guidelineString = Files.readString(
        Path.of(parser.parse("https://azure.github.io/azure-sdk/java_introduction.html")));
    JsonArray guidelineArray = JsonParser.parseString(guidelineString).getAsJsonArray();
    String headings = "";
    String codeHeader = "";
    String output = "";
    String methods = "";
    String prompt = "";

    for (JsonElement element : guidelineArray) {
      headings += element.getAsJsonObject().get("heading").getAsString() + "\n";
    }
    Map<String, String> newMap = null;
    try {
      newMap = fragmenter.fragment(
          new File(
              "D:\\UpdatedMCP\\AIConvenienceAPI\\TypeSpec_Conversion\\tsp-output\\clients\\java\\src\\main\\java\\azurestoragemanagement\\BlobContainersClient.java"));
      codeHeader = newMap.get("Header");
      newMap.remove("Header");
      methods = newMap.keySet().toString();
      linked = linker.link(newMap);

    } catch (IOException e) {
      e.printStackTrace();
    }

    // ########################################
    // First Prompt (Flags Method Names & Guidelines from List)
    // ########################################
    prompt = Files.readString(Path.of("D:\\UpdatedMCP\\AIConvenienceAPI\\Prompts\\MethodsGuidelinesPrompt.txt"));
    prompt = prompt.replace("{methodNames}", methods);
    prompt = prompt.replace("{guidelines}", headings);

    // Call the AI, returns
    String outputMethodsGuidelines = sendFragments(client, prompt);

    // Appends prompt + output to file
    // TODO: Implement logging to format the output better
    reportBuilder.append(
        "\n\n===========================================================================================\n");
    reportBuilder.append("Prompt 1\n");
    reportBuilder.append(
        "===========================================================================================\n\n\n");
    reportBuilder.append(prompt);
    reportBuilder.append(
        "\n===========================================================================================\n\n\n\n");
    reportBuilder.append(
        "\n===========================================================================================\n");
    reportBuilder.append("Step 1 Output: Method and Guideline request\n");
    reportBuilder.append(
        "===========================================================================================\n\n");
    reportBuilder.append(outputMethodsGuidelines);
    reportBuilder.append(
        "\n===========================================================================================\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");

    // Fallback for when the AI cannot find improvements
    if (outputMethodsGuidelines.toLowerCase().equals("no")) {
      System.out.println("No patterns found in code. Stopping all further operations");
      return reportBuilder.toString();
    }

    // Format the output to be used for next prompt
    JsonObject JSONMethodsGuidelines = JsonParser.parseString(outputMethodsGuidelines).getAsJsonObject();

    JsonArray methodsArray = JSONMethodsGuidelines.getAsJsonArray("methods");
    JsonArray guidelineHeaderArray = JSONMethodsGuidelines.getAsJsonArray("guidelines");

    Map<String, String> flaggedMethods = new HashMap<>();
    Map<String, String> flaggedGuidelines = new HashMap<>();

    // Attach code to each flagged method
    for (JsonElement e : methodsArray) {
      assert newMap != null;
      String methodName = e.getAsString().trim();
      String code = newMap.get(methodName + "(");

      // If method name exists in map
      if (code != null) {
        // Attach code to method name entry
        flaggedMethods.put(
            methodName,
            newMap.get(methodName + "(")); // The '(' is on all map entry names for pattern matching
      }
    }

    // Attach guideline to guideline header
    for (JsonElement flaggedGuideline : guidelineHeaderArray) {
      String flaggedGuidelineHeader = flaggedGuideline.getAsString().trim();

      for (JsonElement guideline : guidelineArray) {
        String heading = guideline.getAsJsonObject().get("heading").getAsString().trim();

        if (heading.equals(flaggedGuidelineHeader)) {
          String guidelineContent = guideline.getAsJsonObject().get("content").getAsString().trim();
          flaggedGuidelines.put(heading, guidelineContent);
          break;
        }
      }
    }

    // ########################################
    // Second (Main) Prompt (Generates wrapper from flagged code and guidelines)
    // ########################################
    String selectedCode = "";
    String selectedGuidelines = "";
    prompt = Files.readString(Path.of("D:\\UpdatedMCP\\AIConvenienceAPI\\Prompts\\MainPrompt.txt"));

    for (Map.Entry<String, String> method : flaggedMethods.entrySet()) {
      selectedCode += method.getValue() + "\n";
    }
    for (Map.Entry<String, String> guideline : flaggedGuidelines.entrySet()) {
      selectedGuidelines += guideline.getKey() + "\n" + guideline.getValue() + "\n\n";
    }

    prompt = prompt.replace("{code}", selectedCode);
    prompt = prompt.replace("{guidelines}", selectedGuidelines);

    String outputWrapper = sendFragments(client, prompt);
    reportBuilder.append(
        "===========================================================================================\n");
    reportBuilder.append("Prompt 2\n");
    reportBuilder.append(
        "===========================================================================================\n\n");
    reportBuilder.append(prompt);
    reportBuilder.append(
        "\n===========================================================================================\n\n\n\n\n");

    // Fallback for when the AI cannot find improvements
    if (outputWrapper.toLowerCase().equals("no")) {
      System.out.println("No patterns found in code. Stopping all further operations");
      return reportBuilder.toString();
    }
    reportBuilder.append(
        "===========================================================================================\n");
    reportBuilder.append("Step 2 Output: Generated Wrapper\n");
    reportBuilder.append(
        "===========================================================================================\n");
    reportBuilder.append(outputWrapper);
    reportBuilder.append(
        "\n===========================================================================================\n\n");

    // Write to file
    Files.writeString(
        outputPath, reportBuilder.toString(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);

    System.out.println("Java Wrapper saved to file");
    return reportBuilder.toString();
  }

  // Get Sync Tool Specification
  private static McpServerFeatures.SyncToolSpecification getSyncToolSpecification() {
    // Create and return a SyncToolSpecification instance
    String schema = "{\n" +
        "    \"type\": \"object\",\n" +
        "    \"properties\": {\n" +
        "        \"input\": {\n" +
        "            \"type\": \"string\"\n" +
        "        },\n" +
        "        \"output\": {\n" +
        "            \"type\": \"string\"\n" +
        "        }\n" +
        "    }\n" +
        "}";
    return new McpServerFeatures.SyncToolSpecification(
        new McpSchema.Tool("Blob-Storage-Generate-Convenience-Wrapper",
            "Generates Convenience Wrapper for blob storage Azure API", schema),
        (exchange, arguments) -> {
          // Define the behavior for the tool specification
          try {
            // Load configuration properties
            loadConfigProperties();
            // Initialize
            OpenAIClient client = createOpenAIClient();
            String result = prepareFragments(client);

            // Return the generated wrapper as tool result
            return new McpSchema.CallToolResult(result, false);

          } catch (ClientAuthenticationException e) {
            String errorMsg = "Authentication failed: " + e.getMessage()
                + "\nPlease check your API key and endpoint.";
            System.err.println(errorMsg);
            return new McpSchema.CallToolResult(errorMsg, true);

          } catch (IOException e) {
            String errorMsg = "File reading error: " + e.getMessage();
            System.err.println(errorMsg);
            e.printStackTrace();
            return new McpSchema.CallToolResult(errorMsg, true);

          } catch (Exception e) {
            String errorMsg = "Error occurred: " + e.getMessage();
            System.err.println(errorMsg);
            e.printStackTrace();
            return new McpSchema.CallToolResult(errorMsg, true);

          }
        });
  }

  public static void main(String[] args) throws Exception {
    // STDIO Server Transport
    var transportProvider = new StdioServerTransportProvider(new ObjectMapper());

    // Create Sync Tool Specification
    var syncToolSpec = getSyncToolSpecification();

    // Create MCP Server
    McpServer.sync(transportProvider)
        .serverInfo("JavaConnector-MCP-Server", "1.0.0")
        .capabilities(McpSchema.ServerCapabilities.builder()
            .tools(true)
            .logging()
            .build())
        .tools(syncToolSpec).build();

    Log.info("MCP Server created successfully");
  }

}
