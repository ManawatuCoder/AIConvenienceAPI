Java Convenience Wrapper Generated by Azure OpenAI\nGenerated: 2025-10-19_18-06\nSource File: C:\Users\Pease\Documents\codes\Personal\uni\Capstone\wrappergenerator\azure-sdks\ai-src\DatasetsClient.java\n\n\n/**
 * Creates or updates a DatasetVersion and immediately retrieves the resulting DatasetVersion.
 * <p>
 * This method streamlines the common workflow of upserting a DatasetVersion and then fetching its server-generated state,
 * such as IDs, tags, or computed fields. It ensures the returned object reflects the persisted state as stored by the service.
 * </p>
 */
public DatasetVersion upsertAndFetchDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
    /*
      Combined Methods: createOrUpdateDatasetVersion, getDatasetVersion
      Reason: Developers often want to confirm the persisted state of a DatasetVersion after upsert, including any default values or server-side modifications. This wrapper eliminates the need for two manual calls and ensures the returned object matches the service-side resource.
    */
    createOrUpdateDatasetVersion(name, version, datasetVersion);
    return getDatasetVersion(name, version);
}

/**
 * Deletes a DatasetVersion if it exists, and returns whether the deletion was successful.
 * <p>
 * This method simplifies the common workflow of attempting to delete a DatasetVersion, returning a boolean to indicate
 * whether the resource was actually deleted (true) or did not exist (false). It handles 404 (not found) gracefully.
 * </p>
 */
public boolean deleteDatasetVersionIfExists(String name, String version) {
    /*
      Combined Methods: deleteDatasetVersionWithResponse
      Reason: Deleting a resource often requires checking for existence and handling not-found errors. This wrapper provides a simple boolean result, reducing error handling boilerplate for the common "delete if exists" scenario.
    */
    try {
        deleteDatasetVersionWithResponse(name, version, new RequestOptions());
        return true;
    } catch (ResourceNotFoundException ex) {
        return false;
    }
}

/**
 * Creates a new DatasetVersion with minimal required information.
 * <p>
 * This method provides a streamlined way to create a DatasetVersion when only the required fields are known.
 * Optional fields are omitted, and sensible defaults are applied.
 * </p>
 */
public DatasetVersion createDatasetVersion(String name, String version, String type, String dataUri) {
    /*
      Combined Methods: createOrUpdateDatasetVersion
      Reason: Creating a DatasetVersion often only requires a few required fields. This wrapper reduces boilerplate by constructing the DatasetVersion model with only the essentials, enabling a quick-start experience for common scenarios.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}/**
 * Retrieves all versions of a dataset, with an option to only return the latest version for each dataset.
 * <p>
 * This method simplifies the common workflow of listing dataset versions, allowing developers to specify whether they want all versions or just the latest ones, without needing to call separate methods.
 * </p>
 *
 * @param name The name of the dataset. If null, retrieves the latest version for all datasets.
 * @param latestOnly If true, returns only the latest version for each dataset; if false, returns all versions for the specified dataset.
 * @return A paged collection of {@link DatasetVersion} items.
 */
public PagedIterable<DatasetVersion> listDatasetVersions(String name, boolean latestOnly) {
    /*
      Combined Methods: listDatasetVersions, listLatestDatasetVersions
      Reason: Developers often want to either list all versions for a dataset or just the latest versions across datasets.
      This wrapper unifies both workflows, reducing the need for conditional logic and method selection in user code.
    */
    if (latestOnly) {
        // If name is provided, filter results to that dataset after fetching all latest versions
        if (name != null) {
            return serviceClient.listLatestDatasetVersions(new RequestOptions())
                .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class))
                .stream()
                .filter(v -> name.equals(v.getName()))
                .collect(PagedIterable.toPagedIterable());
        } else {
            return serviceClient.listLatestDatasetVersions(new RequestOptions())
                .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
        }
    } else {
        if (name == null) {
            throw new IllegalArgumentException("Dataset name must be provided when latestOnly is false.");
        }
        return serviceClient.listDatasetVersions(name, new RequestOptions())
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }
}

/**
 * Retrieves all versions of the specified dataset.
 * <p>
 * This method provides a streamlined way to list all versions for a dataset, using a sensible default for request options.
 * </p>
 *
 * @param name The name of the dataset.
 * @return A paged collection of {@link DatasetVersion} items.
 */
public PagedIterable<DatasetVersion> listAllDatasetVersions(String name) {
    /*
      Combined Methods: listDatasetVersions
      Reason: Provides a clear, intent-revealing method name for the common scenario of listing all versions for a dataset, reducing ambiguity and boilerplate.
    */
    return serviceClient.listDatasetVersions(name, new RequestOptions())
        .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
}

/**
 * Retrieves the latest version of each dataset.
 * <p>
 * This method provides a clear, intent-revealing method name for the common scenario of listing only the latest versions, reducing ambiguity and boilerplate.
 * </p>
 *
 * @return A paged collection of {@link DatasetVersion} items.
 */
public PagedIterable<DatasetVersion> listAllLatestDatasetVersions() {
    /*
      Combined Methods: listLatestDatasetVersions
      Reason: Provides a clear, intent-revealing method name for the common scenario of listing only the latest versions, reducing ambiguity and boilerplate.
    */
    return serviceClient.listLatestDatasetVersions(new RequestOptions())
        .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
}/**
 * Initiates a new pending upload or retrieves an existing one for a dataset version, using only required parameters and sensible defaults for common scenarios.
 * <p>
 * This method streamlines the process of starting or retrieving a pending upload by requiring only the dataset name, version, and upload type. Optional parameters are omitted for simplicity.
 * </p>
 *
 * @param name The name of the dataset.
 * @param version The version of the dataset.
 * @param pendingUploadType The type of pending upload ("None" or "BlobReference").
 * @return The response containing pending upload details.
 */
public PendingUploadResponse startOrGetPendingUpload(String name, String version, String pendingUploadType) {
    /*
      Combined Methods: pendingUpload(String, String, PendingUploadRequest)
      Reason: Simplifies the most common workflow by requiring only the essential parameters (name, version, type), 
      and internally constructs the PendingUploadRequest. This eliminates boilerplate and reduces user error in constructing the request object for standard cases.
    */
    PendingUploadRequest request = new PendingUploadRequest().setPendingUploadType(pendingUploadType);
    return pendingUpload(name, version, request);
}

/**
 * Initiates a new pending upload or retrieves an existing one for a dataset version, allowing the caller to specify a connection name.
 * <p>
 * This method streamlines the process of starting or retrieving a pending upload by requiring only the dataset name, version, upload type, and connection name.
 * </p>
 *
 * @param name The name of the dataset.
 * @param version The version of the dataset.
 * @param pendingUploadType The type of pending upload ("None" or "BlobReference").
 * @param connectionName The name of the connection to use.
 * @return The response containing pending upload details.
 */
public PendingUploadResponse startOrGetPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
    /*
      Combined Methods: pendingUpload(String, String, PendingUploadRequest)
      Reason: Further streamlines the workflow for scenarios where a connection name is commonly specified, 
      reducing manual construction of the PendingUploadRequest and improving clarity.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType(pendingUploadType)
        .setConnectionName(connectionName);
    return pendingUpload(name, version, request);
}

/**
 * Initiates or retrieves a pending upload for a dataset version, returning the HTTP response for advanced scenarios.
 * <p>
 * This method provides a simplified overload for the maximal pendingUploadWithResponse method, 
 * constructing the request body from the essential parameters and applying default request options.
 * </p>
 *
 * @param name The name of the dataset.
 * @param version The version of the dataset.
 * @param pendingUploadType The type of pending upload ("None" or "BlobReference").
 * @return The HTTP response containing pending upload details as a strongly-typed object.
 */
public Response<PendingUploadResponse> startOrGetPendingUploadWithResponse(String name, String version, String pendingUploadType) {
    /*
      Combined Methods: pendingUploadWithResponse(String, String, BinaryData, RequestOptions)
      Reason: Reduces friction for users who require the full HTTP response, by handling the construction of the request body and default RequestOptions internally.
    */
    PendingUploadRequest request = new PendingUploadRequest().setPendingUploadType(pendingUploadType);
    Response<BinaryData> response = pendingUploadWithResponse(name, version, BinaryData.fromObject(request), new RequestOptions());
    return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), response.getValue().toObject(PendingUploadResponse.class));
}/**
 * Creates or updates a dataset version from a local file or folder path.
 * <p>
 * This method automatically detects if the provided path is a file or a directory, uploads the content accordingly,
 * and creates or updates the corresponding dataset version in the service. This streamlines the workflow for dataset
 * registration by handling upload, SAS negotiation, and dataset version creation in one call.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param path The local file or folder path to upload.
 * @return The created or updated dataset version, as either FileDatasetVersion or FolderDatasetVersion.
 * @throws IllegalArgumentException If the path does not exist or is not a file/folder.
 * @throws IOException If an I/O error occurs during folder traversal.
 */
public Object createOrUpdateDatasetVersion(String name, String version, Path path) throws IOException {
    /*
      Combined Methods: createDatasetWithFile, createDatasetWithFolder
      Reason: Developers often want to register a dataset from a local path without having to distinguish file vs. folder logic.
      This wrapper detects the path type, performs the correct upload workflow, and returns the appropriate dataset version object.
      It eliminates repetitive branching and error handling in user code.
    */
    if (Files.isRegularFile(path)) {
        return createDatasetWithFile(name, version, path);
    } else if (Files.isDirectory(path)) {
        return createDatasetWithFolder(name, version, path);
    } else {
        throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
    }
}

/**
 * Creates or updates a dataset version from a local file, with optional description and tags.
 * <p>
 * This method provides a simplified workflow for the common case of registering a file as a dataset version,
 * allowing the caller to specify optional metadata (description, tags) without manually constructing model objects.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param filePath The local file path to upload.
 * @param description Optional description for the dataset version.
 * @param tags Optional tags for the dataset version.
 * @return The created or updated FileDatasetVersion.
 * @throws IllegalArgumentException If the path is not a file.
 */
public FileDatasetVersion createDatasetVersionFromFile(
    String name,
    String version,
    Path filePath,
    String description,
    Map<String, String> tags
) {
    /*
      Combined Methods: createDatasetWithFile, createOrUpdateDatasetVersionWithResponse
      Reason: Developers frequently want to register a file as a dataset version and attach metadata in one step.
      This wrapper exposes common metadata (description, tags) as parameters, removing the need to manually construct
      model objects or call multiple methods.
    */
    if (!Files.isRegularFile(filePath)) {
        throw new IllegalArgumentException("The provided path is not a file: " + filePath);
    }
    FileDatasetVersion datasetVersion = createDatasetWithFile(name, version, filePath);
    if (description != null) {
        datasetVersion.setDescription(description);
    }
    if (tags != null) {
        datasetVersion.setTags(tags);
    }
    // Update dataset version with metadata if provided
    if (description != null || tags != null) {
        createOrUpdateDatasetVersionWithResponse(
            name,
            version,
            BinaryData.fromObject(datasetVersion),
            new RequestOptions()
        );
    }
    return datasetVersion;
}

/**
 * Creates or updates a dataset version from a local folder, with optional description and tags.
 * <p>
 * This method provides a streamlined workflow for registering a folder as a dataset version,
 * allowing the caller to specify optional metadata (description, tags) without manually constructing model objects.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param folderPath The local folder path to upload.
 * @param description Optional description for the dataset version.
 * @param tags Optional tags for the dataset version.
 * @return The created or updated FolderDatasetVersion.
 * @throws IllegalArgumentException If the path is not a directory.
 * @throws IOException If an I/O error occurs during folder traversal.
 */
public FolderDatasetVersion createDatasetVersionFromFolder(
    String name,
    String version,
    Path folderPath,
    String description,
    Map<String, String> tags
) throws IOException {
    /*
      Combined Methods: createDatasetWithFolder, createOrUpdateDatasetVersionWithResponse
      Reason: Developers frequently want to register a folder as a dataset version and attach metadata in one step.
      This wrapper exposes common metadata (description, tags) as parameters, removing the need to manually construct
      model objects or call multiple methods.
    */
    if (!Files.isDirectory(folderPath)) {
        throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
    }
    FolderDatasetVersion datasetVersion = createDatasetWithFolder(name, version, folderPath);
    if (description != null) {
        datasetVersion.setDescription(description);
    }
    if (tags != null) {
        datasetVersion.setTags(tags);
    }
    // Update dataset version with metadata if provided
    if (description != null || tags != null) {
        createOrUpdateDatasetVersionWithResponse(
            name,
            version,
            BinaryData.fromObject(datasetVersion),
            new RequestOptions()
        );
    }
    return datasetVersion;
}/**
 * Retrieves a SAS credential for a dataset version and returns the parsed result directly, handling all necessary request setup.
 */
public AssetCredentialResult getDatasetVersionSasCredential(String datasetName, String version) {
    /*
      Combined Methods: getCredentialsWithResponse, getCredentials
      Reason: Developers primarily want the SAS credential for a dataset version. This wrapper eliminates the need to manually construct RequestOptions, call the low-level method, and deserialize the response. It streamlines the common workflow of fetching credentials for a dataset version, providing a single, intent-revealing method with sensible defaults.
    */
    return getCredentials(datasetName, version);
}

/**
 * Retrieves a SAS credential for a dataset version, returning the full HTTP response for advanced scenarios.
 */
public Response<AssetCredentialResult> getDatasetVersionSasCredentialWithResponse(String datasetName, String version, RequestOptions requestOptions) {
    /*
      Combined Methods: getCredentialsWithResponse
      Reason: Developers who need access to HTTP response metadata (headers, status, etc.) and a deserialized result can use this wrapper. It hides the BinaryData-to-object conversion, returning a strongly-typed response and reducing manual deserialization boilerplate.
    */
    Response<BinaryData> response = getCredentialsWithResponse(datasetName, version, requestOptions);
    AssetCredentialResult result = response.getValue().toObject(AssetCredentialResult.class);
    return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), result);
}