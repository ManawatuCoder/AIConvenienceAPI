Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-07_00-40


/**
 * Combined Methods: create, createWithResponse
 * Reason: Both methods create a new container, with one returning a simple result and the other returning a Response with additional metadata. Wrapping them provides a single entry point using the options pattern, improving discoverability and reducing overload confusion.
 * 
 * Comment: Creates a new container under the specified account. If a RequestContext is provided in the options, returns a Response with metadata; otherwise, returns the created BlobContainer.
 */
public Object createContainer(CreateContainerOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.createWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getBlobContainer(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.create(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getBlobContainer()
        );
    }
}

/**
 * Combined Methods: update, updateWithResponse
 * Reason: Both methods update container properties, with one returning a simple result and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations for complex operations.
 * 
 * Comment: Updates container properties as specified in the options. Returns a Response if RequestContext is provided; otherwise, returns the updated BlobContainer.
 */
public Object updateContainer(UpdateContainerOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.updateWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getBlobContainer(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.update(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getBlobContainer()
        );
    }
}

/**
 * Combined Methods: delete, deleteWithResponse
 * Reason: Both methods delete a specified container, with one returning void and the other returning a Response. Wrapping them provides a single entry point, using the options pattern for consistency and developer convenience.
 * 
 * Comment: Deletes the specified container. Returns a Response if RequestContext is provided; otherwise, performs the delete operation without returning a value.
 */
public Object deleteContainer(DeleteContainerOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.deleteWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getRequestContext()
        );
    } else {
        this.serviceClient.delete(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion()
        );
        return null;
    }
}

/**
 * Combined Methods: get, getWithResponse
 * Reason: Both methods retrieve container properties, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Gets properties of a specified container. Returns a Response if RequestContext is provided; otherwise, returns the BlobContainer.
 */
public Object getContainer(GetContainerOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.getWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.get(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion()
        );
    }
}

/**
 * Combined Methods: list, listWithResponse
 * Reason: Both methods list containers, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations for paged operations.
 * 
 * Comment: Lists all containers. Returns a Response if additional parameters or RequestContext are provided; otherwise, returns the ListContainerItems directly.
 */
public Object listContainers(ListContainersOptions options) {
    if (options.getRequestContext() != null || options.getMaxPageSize() != null || options.getFilter() != null || options.getInclude() != null) {
        return this.serviceClient.listWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getApiVersion(),
            options.getMaxPageSize(),
            options.getFilter(),
            options.getInclude(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.list(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getApiVersion()
        );
    }
}

/**
 * Combined Methods: clearLegalHold, clearLegalHoldWithResponse
 * Reason: Both methods clear legal hold tags, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Clears legal hold tags for a container. Returns a Response if RequestContext is provided; otherwise, returns the LegalHold.
 */
public Object clearLegalHold(ClearLegalHoldOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.clearLegalHoldWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getLegalHold(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.clearLegalHold(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getLegalHold()
        );
    }
}

/**
 * Combined Methods: setLegalHold, setLegalHoldWithResponse
 * Reason: Both methods set legal hold tags, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Sets legal hold tags for a container. Returns a Response if RequestContext is provided; otherwise, returns the LegalHold.
 */
public Object setLegalHold(SetLegalHoldOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.setLegalHoldWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getLegalHold(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.setLegalHold(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getLegalHold()
        );
    }
}

/**
 * Combined Methods: getImmutabilityPolicy, getImmutabilityPolicyWithResponse
 * Reason: Both methods retrieve the immutability policy, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Gets the existing immutability policy along with the corresponding ETag. Returns a Response if ifMatch and RequestContext are provided; otherwise, returns the ImmutabilityPolicy.
 */
public Object getImmutabilityPolicy(GetImmutabilityPolicyOptions options) {
    if (options.getIfMatch() != null && options.getRequestContext() != null) {
        return this.serviceClient.getImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.getImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion()
        );
    }
}

/**
 * Combined Methods: deleteImmutabilityPolicy, deleteImmutabilityPolicyWithResponse
 * Reason: Both methods abort an unlocked immutability policy, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Aborts an unlocked immutability policy. Returns a Response if RequestContext is provided; otherwise, returns the ImmutabilityPolicy.
 */
public Object deleteImmutabilityPolicy(DeleteImmutabilityPolicyOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.deleteImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.deleteImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch()
        );
    }
}

/**
 * Combined Methods: lockImmutabilityPolicy, lockImmutabilityPolicyWithResponse
 * Reason: Both methods lock the immutability policy, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Sets the ImmutabilityPolicy to Locked state. Returns a Response if RequestContext is provided; otherwise, returns the ImmutabilityPolicy.
 */
public Object lockImmutabilityPolicy(LockImmutabilityPolicyOptions options) {
    if (options.getRequestContext() != null) {
        return this.serviceClient.lockImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.lockImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch()
        );
    }
}

/**
 * Combined Methods: createOrUpdateImmutabilityPolicy, createOrUpdateImmutabilityPolicyWithResponse
 * Reason: Both methods create or update an unlocked immutability policy, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Creates or updates an unlocked immutability policy. Returns a Response if ifMatch, parameters, and RequestContext are provided; otherwise, returns the ImmutabilityPolicy.
 */
public Object createOrUpdateImmutabilityPolicy(CreateOrUpdateImmutabilityPolicyOptions options) {
    if (options.getIfMatch() != null && options.getParameters() != null && options.getRequestContext() != null) {
        return this.serviceClient.createOrUpdateImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getParameters(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.createOrUpdateImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion()
        );
    }
}

/**
 * Combined Methods: extendImmutabilityPolicy, extendImmutabilityPolicyWithResponse
 * Reason: Both methods extend the immutability period of a locked immutability policy, with one returning the logical entity and the other returning a Response. Wrapping them using the options pattern simplifies usage and aligns with guideline recommendations.
 * 
 * Comment: Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. Returns a Response if parameters and RequestContext are provided; otherwise, returns the ImmutabilityPolicy.
 */
public Object extendImmutabilityPolicy(ExtendImmutabilityPolicyOptions options) {
    if (options.getParameters() != null && options.getRequestContext() != null) {
        return this.serviceClient.extendImmutabilityPolicyWithResponse(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch(),
            options.getParameters(),
            options.getRequestContext()
        );
    } else {
        return this.serviceClient.extendImmutabilityPolicy(
            options.getSubscriptionId(),
            options.getResourceGroupName(),
            options.getAccountName(),
            options.getContainerName(),
            options.getApiVersion(),
            options.getIfMatch()
        );
    }
}