Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-06_23-42


/**
 * Combined Methods: create, createWithResponse
 * Reason: Both methods create a new blob container and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for container creation, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Creates a new blob container under the specified account. If requestContext is provided, returns a Response<BlobContainer>; otherwise, returns BlobContainer.
 */
public Object createContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, BlobContainer blobContainer, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.createWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer, requestContext);
    } else {
        return this.serviceClient.create(subscriptionId, resourceGroupName, accountName, containerName, apiVersion,
            blobContainer);
    }
}

/**
 * Combined Methods: update, updateWithResponse
 * Reason: Both methods update a blob container and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for updating container properties, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Updates properties of a blob container. If requestContext is provided, returns a Response<BlobContainer>; otherwise, returns BlobContainer.
 */
public Object updateContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, BlobContainer blobContainer, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.updateWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer, requestContext);
    } else {
        return this.serviceClient.update(subscriptionId, resourceGroupName, accountName, containerName, apiVersion,
            blobContainer);
    }
}

/**
 * Combined Methods: delete, deleteWithResponse
 * Reason: Both methods delete a blob container and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for container deletion, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Deletes a blob container. If requestContext is provided, returns Response<Void>; otherwise, returns void.
 */
public Object deleteContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.deleteWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, requestContext);
    } else {
        this.serviceClient.delete(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
        return null;
    }
}

/**
 * Combined Methods: get, getWithResponse
 * Reason: Both methods get properties of a blob container and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for retrieving container properties, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Gets properties of a blob container. If requestContext is provided, returns Response<BlobContainer>; otherwise, returns BlobContainer.
 */
public Object getContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.getWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, requestContext);
    } else {
        return this.serviceClient.get(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
    }
}

/**
 * Combined Methods: list, listWithResponse
 * Reason: Both methods list blob containers and differ only in whether they return a Response wrapper and support additional parameters. Wrapping them provides a single entry point for listing containers, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Lists blob containers. If requestContext is provided, returns Response<ListContainerItems>; otherwise, returns ListContainerItems.
 */
public Object listContainers(String subscriptionId, String resourceGroupName, String accountName,
    String apiVersion, String maxpagesize, String filter, ListContainersInclude include, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.listWithResponse(subscriptionId, resourceGroupName, accountName, apiVersion,
            maxpagesize, filter, include, requestContext);
    } else {
        return this.serviceClient.list(subscriptionId, resourceGroupName, accountName, apiVersion);
    }
}

/**
 * Combined Methods: setLegalHold, setLegalHoldWithResponse
 * Reason: Both methods set legal hold tags and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for setting legal hold tags, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Sets legal hold tags on a blob container. If requestContext is provided, returns Response<LegalHold>; otherwise, returns LegalHold.
 */
public Object setContainerLegalHold(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, LegalHold legalHold, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.setLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, legalHold, requestContext);
    } else {
        return this.serviceClient.setLegalHold(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold);
    }
}

/**
 * Combined Methods: clearLegalHold, clearLegalHoldWithResponse
 * Reason: Both methods clear legal hold tags and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for clearing legal hold tags, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Clears legal hold tags on a blob container. If requestContext is provided, returns Response<LegalHold>; otherwise, returns LegalHold.
 */
public Object clearContainerLegalHold(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, LegalHold legalHold, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.clearLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, legalHold, requestContext);
    } else {
        return this.serviceClient.clearLegalHold(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold);
    }
}

/**
 * Combined Methods: getImmutabilityPolicy, getImmutabilityPolicyWithResponse
 * Reason: Both methods get the immutability policy and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for retrieving the immutability policy, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Gets the immutability policy of a blob container. If requestContext is provided, returns Response<ImmutabilityPolicy>; otherwise, returns ImmutabilityPolicy.
 */
public Object getContainerImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.getImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, requestContext);
    } else {
        return this.serviceClient.getImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion);
    }
}

/**
 * Combined Methods: deleteImmutabilityPolicy, deleteImmutabilityPolicyWithResponse
 * Reason: Both methods delete the immutability policy and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for deleting the immutability policy, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Deletes the immutability policy of a blob container. If requestContext is provided, returns Response<ImmutabilityPolicy>; otherwise, returns ImmutabilityPolicy.
 */
public Object deleteContainerImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.deleteImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, requestContext);
    } else {
        return this.serviceClient.deleteImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, ifMatch);
    }
}

/**
 * Combined Methods: lockImmutabilityPolicy, lockImmutabilityPolicyWithResponse
 * Reason: Both methods lock the immutability policy and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for locking the immutability policy, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Locks the immutability policy of a blob container. If requestContext is provided, returns Response<ImmutabilityPolicy>; otherwise, returns ImmutabilityPolicy.
 */
public Object lockContainerImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.lockImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, requestContext);
    } else {
        return this.serviceClient.lockImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, ifMatch);
    }
}

/**
 * Combined Methods: extendImmutabilityPolicy, extendImmutabilityPolicyWithResponse
 * Reason: Both methods extend the immutability policy and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for extending the immutability policy, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Extends the immutability policy of a blob container. If requestContext is provided, returns Response<ImmutabilityPolicy>; otherwise, returns ImmutabilityPolicy.
 */
public Object extendContainerImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, ImmutabilityPolicy parameters, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.extendImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, parameters, requestContext);
    } else {
        return this.serviceClient.extendImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, ifMatch);
    }
}

/**
 * Combined Methods: createOrUpdateImmutabilityPolicy, createOrUpdateImmutabilityPolicyWithResponse
 * Reason: Both methods create or update the immutability policy and differ only in whether they return a Response wrapper. Wrapping them provides a single entry point for creating or updating the immutability policy, allowing the developer to choose whether to receive full response details or just the logical entity.
 * 
 * Comment: Creates or updates the immutability policy of a blob container. If requestContext is provided, returns Response<ImmutabilityPolicy>; otherwise, returns ImmutabilityPolicy.
 */
public Object createOrUpdateContainerImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, ImmutabilityPolicy parameters, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.createOrUpdateImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName,
            accountName, containerName, apiVersion, ifMatch, parameters, requestContext);
    } else {
        return this.serviceClient.createOrUpdateImmutabilityPolicy(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion);
    }
}