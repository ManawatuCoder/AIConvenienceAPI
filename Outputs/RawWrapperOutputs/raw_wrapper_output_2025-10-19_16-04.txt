Java Convenience Wrapper Generated by Azure OpenAI\nGenerated: 2025-10-19_16-04\nSource File: C:\Users\New\Desktop\uni\2025\AIConvenienceAPI\azure-sdks\ai-src\DatasetsClient.java\n\n\n/**
 * Creates or updates a DatasetVersion and immediately retrieves the resulting DatasetVersion.
 * <p>
 * This wrapper streamlines the common workflow of upserting a DatasetVersion and then fetching its latest state,
 * ensuring the returned object reflects any server-side transformations or defaults applied during creation or update.
 * </p>
 */
public DatasetVersion upsertAndFetchDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
    /*
      Combined Methods: createOrUpdateDatasetVersion, getDatasetVersion
      Reason: Developers frequently want to confirm the persisted state of a DatasetVersion after upsert, including any server-generated fields or normalization. This wrapper eliminates the need for two separate calls and reduces boilerplate, while preserving all underlying functionality.
    */
    createOrUpdateDatasetVersion(name, version, datasetVersion);
    return getDatasetVersion(name, version);
}

/**
 * Deletes a specific DatasetVersion if it exists, and returns whether the version was present and deleted.
 * <p>
 * This wrapper streamlines the common workflow of attempting to delete a DatasetVersion, 
 * and learning if the resource previously existed, without requiring manual exception handling for 404.
 * </p>
 */
public boolean deleteDatasetVersionIfExists(String name, String version) {
    /*
      Combined Methods: deleteDatasetVersion, getDatasetVersion
      Reason: Deleting a resource often requires first checking for existence or handling 404 exceptions. This wrapper provides a safe, intent-revealing pattern that returns true if the resource was deleted, or false if it did not exist, reducing error-prone boilerplate and improving clarity.
    */
    try {
        getDatasetVersion(name, version);
        deleteDatasetVersion(name, version);
        return true;
    } catch (ResourceNotFoundException ex) {
        return false;
    }
}

/**
 * Creates a new DatasetVersion with only required parameters.
 * <p>
 * This wrapper provides a streamlined way to create a DatasetVersion when only the required fields are known,
 * applying sensible defaults for optional parameters.
 * </p>
 */
public DatasetVersion createDatasetVersion(String name, String version, String type, String dataUri) {
    /*
      Combined Methods: createOrUpdateDatasetVersion
      Reason: Creating a DatasetVersion often only requires a few fields, but the model has many optional properties. This wrapper reduces friction by allowing creation with only the required fields, encouraging best practices and reducing boilerplate.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}/**
 * Returns the latest version of a DatasetVersion for a given dataset name.
 *
 * <p>This method simplifies the common workflow of retrieving the most recent version of a dataset, 
 * which would otherwise require listing all versions and then manually determining the latest.</p>
 *
 * @param name The name of the dataset.
 * @return The latest DatasetVersion for the specified dataset, or null if none exist.
 */
public DatasetVersion getLatestDatasetVersion(String name) {
    /*
      Combined Methods: listDatasetVersions
      Reason: Developers often want the latest version of a dataset. This wrapper encapsulates the common pattern of retrieving all versions and selecting the latest, reducing boilerplate and potential errors in sorting/filtering.
    */
    PagedIterable<DatasetVersion> versions = listDatasetVersions(name);
    DatasetVersion latest = null;
    for (DatasetVersion version : versions) {
        if (latest == null || version.getVersion().compareTo(latest.getVersion()) > 0) {
            latest = version;
        }
    }
    return latest;
}

/**
 * Returns a mapping from dataset name to its latest DatasetVersion for all datasets.
 *
 * <p>This method streamlines the workflow of retrieving the latest version for every dataset, 
 * which would otherwise require listing all latest versions and grouping them manually.</p>
 *
 * @return A map where the key is the dataset name and the value is its latest DatasetVersion.
 */
public Map<String, DatasetVersion> listLatestDatasetVersionsByName() {
    /*
      Combined Methods: listLatestDatasetVersions
      Reason: Developers frequently need to work with the latest version of each dataset. This wrapper provides a ready-to-use mapping, reducing the need for manual iteration and grouping.
    */
    Map<String, DatasetVersion> result = new HashMap<>();
    for (DatasetVersion version : listLatestDatasetVersions()) {
        result.put(version.getName(), version);
    }
    return result;
}/**
 * Starts or retrieves a pending upload for a dataset version, using only the required parameters.
 * Provides sensible defaults for optional parameters and request options, streamlining the common case.
 */
public PendingUploadResponse startPendingUpload(String datasetName, String version) {
    /*
      Combined Methods: pendingUpload
      Reason: Developers often want to initiate a dataset upload with minimal configuration. This wrapper allows starting a pending upload with only the required dataset name and version, automatically constructing a PendingUploadRequest with default type "BlobReference" and omitting optional fields. This eliminates the need for manual request object construction and reduces boilerplate for the most common scenario.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType("BlobReference");
    return pendingUpload(datasetName, version, request);
}

/**
 * Starts or retrieves a pending upload for a dataset version, specifying a connection name.
 * Simplifies the process by allowing the developer to provide only the connection name in addition to required parameters.
 */
public PendingUploadResponse startPendingUpload(String datasetName, String version, String connectionName) {
    /*
      Combined Methods: pendingUpload
      Reason: Many users need to specify a connection name for storage, but don't want to manually build the request object. This wrapper allows specifying the connection name directly, sets the required pendingUploadType to "BlobReference", and omits other optional fields, reducing repetitive code and clarifying intent.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType("BlobReference")
        .setConnectionName(connectionName);
    return pendingUpload(datasetName, version, request);
}

/**
 * Starts or retrieves a pending upload for a dataset version, optionally specifying a connection name and a pending upload ID.
 * This overload is useful for resuming or referencing an existing pending upload, while still minimizing boilerplate.
 */
public PendingUploadResponse startPendingUpload(String datasetName, String version, String connectionName, String pendingUploadId) {
    /*
      Combined Methods: pendingUpload
      Reason: When resuming or referencing an existing pending upload, developers need to specify both connection name and pending upload ID. This wrapper enables that scenario directly, without requiring manual construction of the request object, streamlining a common workflow.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType("BlobReference")
        .setConnectionName(connectionName)
        .setPendingUploadId(pendingUploadId);
    return pendingUpload(datasetName, version, request);
}/**
 * Creates or updates a dataset version from a local file or folder path.
 * <p>
 * This method intelligently determines whether the provided path is a file or directory,
 * uploads the content to the service, and creates or updates the corresponding dataset version.
 * It eliminates the need for the developer to manually distinguish between file and folder uploads,
 * and handles all necessary upload and registration steps.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The version identifier for the dataset.
 * @param path The local file or folder path to upload.
 * @return The created or updated dataset version (FileDatasetVersion or FolderDatasetVersion).
 * @throws IllegalArgumentException If the path is neither a file nor a directory.
 * @throws IOException If an I/O error occurs during folder traversal.
 */
public Object upsertDatasetVersionFromPath(String name, String version, Path path) throws IOException {
    /*
      Combined Methods: createDatasetWithFile, createDatasetWithFolder, pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: Developers often want to register a dataset version from a local path, but must currently distinguish between file and folder uploads and manually invoke different methods. This wrapper streamlines the workflow by automatically handling both cases, reducing cognitive load and boilerplate, and aligning with the intent of "register this path as a dataset version".
    */
    if (Files.isRegularFile(path)) {
        // Delegate to file upload logic
        return createDatasetWithFile(name, version, path);
    } else if (Files.isDirectory(path)) {
        // Delegate to folder upload logic
        return createDatasetWithFolder(name, version, path);
    } else {
        throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
    }
}

/**
 * Creates or updates a dataset version from a local file, with optional metadata.
 * <p>
 * This method uploads a file and registers it as a dataset version, allowing the caller to specify
 * description and tags in a single call. It provides sensible defaults for optional metadata, reducing
 * the number of steps required for common scenarios.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The version identifier for the dataset.
 * @param filePath The local file path to upload.
 * @param description Optional description for the dataset version.
 * @param tags Optional tags to associate with the dataset version.
 * @return The created or updated FileDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a file.
 */
public FileDatasetVersion upsertFileDatasetVersion(String name, String version, Path filePath, String description, Map<String, String> tags) {
    /*
      Combined Methods: createDatasetWithFile, createOrUpdateDatasetVersionWithResponse
      Reason: Developers often want to upload a file as a dataset version and set metadata (description, tags) in one step. The low-level API requires multiple calls and manual object construction. This wrapper streamlines the workflow, providing a single entry point for the common scenario of file-based dataset registration with metadata.
    */
    if (!Files.isRegularFile(filePath)) {
        throw new IllegalArgumentException("The provided path is not a file: " + filePath);
    }
    PendingUploadRequest body = new PendingUploadRequest();
    PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
    SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
    String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
    BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
    blobClient.upload(BinaryData.fromFile(filePath));
    RequestOptions requestOptions = new RequestOptions();
    FileDatasetVersion datasetVersion = new FileDatasetVersion()
        .setDataUri(blobClient.getBlobUrl())
        .setName(name)
        .setVersion(version)
        .setDescription(description)
        .setTags(tags);
    FileDatasetVersion result = this
        .createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(datasetVersion), requestOptions)
        .getValue()
        .toObject(FileDatasetVersion.class);
    return result;
}

/**
 * Creates or updates a dataset version from a local folder, with optional metadata.
 * <p>
 * This method uploads all files in the specified folder (recursively) and registers them as a folder dataset version,
 * allowing the caller to specify description and tags in a single call. It handles all upload and registration steps,
 * reducing boilerplate for common folder-based dataset registration scenarios.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The version identifier for the dataset.
 * @param folderPath The local folder path to upload.
 * @param description Optional description for the dataset version.
 * @param tags Optional tags to associate with the dataset version.
 * @return The created or updated FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a directory.
 * @throws IOException If an I/O error occurs during folder traversal.
 */
public FolderDatasetVersion upsertFolderDatasetVersion(String name, String version, Path folderPath, String description, Map<String, String> tags) throws IOException {
    /*
      Combined Methods: createDatasetWithFolder, createOrUpdateDatasetVersionWithResponse
      Reason: Developers often want to upload a folder as a dataset version and set metadata (description, tags) in one step. The low-level API requires multiple calls and manual object construction. This wrapper streamlines the workflow, providing a single entry point for the common scenario of folder-based dataset registration with metadata.
    */
    if (!Files.isDirectory(folderPath)) {
        throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
    }
    PendingUploadRequest request = new PendingUploadRequest();
    PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
    String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
    SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
    String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
    Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
        String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath), true);
    });
    RequestOptions requestOptions = new RequestOptions();
    FolderDatasetVersion datasetVersion = new FolderDatasetVersion()
        .setDataUri(containerUrl)
        .setName(name)
        .setVersion(version)
        .setDescription(description)
        .setTags(tags);
    FolderDatasetVersion result = this
        .createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(datasetVersion), requestOptions)
        .getValue()
        .toObject(FolderDatasetVersion.class);
    return result;
}/**
 * Obtains a SAS URI for the dataset version's blob, ready for direct use in storage operations.
 * <p>
 * This method streamlines the process of retrieving a SAS URI for a dataset version's blob, abstracting away
 * the need to manually extract and parse the credential details from the response model.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return The SAS URI string for the dataset version's blob.
 */
public String getDatasetVersionBlobSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers commonly want to access the SAS URI directly for blob operations, but the low-level API
              requires navigating through nested model properties. This wrapper provides a direct, intent-revealing
              method to retrieve the SAS URI, reducing boilerplate and improving clarity for the most common use case.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null || result.getBlobReference().getCredential() == null) {
        throw new IllegalStateException("Unable to retrieve SAS URI: missing credential information.");
    }
    return result.getBlobReference().getCredential().getSasUri();
}

/**
 * Obtains the storage account ARM resource ID associated with a dataset version's blob.
 * <p>
 * This method simplifies access to the storage account ARM ID, which is often needed for resource management
 * or auditing, by extracting it from the nested credential result model.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return The storage account ARM resource ID string.
 */
public String getDatasetVersionStorageAccountArmId(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Accessing the storage account ARM ID is a common scenario for resource tracking or permissions.
              The raw API requires manual traversal of nested models. This wrapper provides a direct, intent-based
              method to retrieve the ARM ID, reducing repetitive code and clarifying developer intent.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null) {
        throw new IllegalStateException("Unable to retrieve storage account ARM ID: missing blob reference.");
    }
    return result.getBlobReference().getStorageAccountArmId();
}

/**
 * Retrieves all credential details for a dataset version's blob in a strongly-typed result.
 * <p>
 * This method provides a streamlined way to obtain all relevant credential information (blob URI, storage account ARM ID,
 * SAS URI, and credential type) in a single call, returning a strongly-typed result for immediate use.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return An object containing blobUri, storageAccountArmId, sasUri, and credentialType.
 */
public DatasetBlobAccessInfo getDatasetVersionBlobAccessInfo(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers often need all relevant access details for a dataset version's blob for downstream operations.
              The low-level API returns a nested model, requiring manual extraction of each property. This wrapper
              returns a simple, purpose-built POJO containing all relevant fields, reducing boilerplate and clarifying intent.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null || result.getBlobReference().getCredential() == null) {
        throw new IllegalStateException("Unable to retrieve blob access info: missing credential information.");
    }
    return new DatasetBlobAccessInfo(
        result.getBlobReference().getBlobUri(),
        result.getBlobReference().getStorageAccountArmId(),
        result.getBlobReference().getCredential().getSasUri(),
        result.getBlobReference().getCredential().getType()
    );
}

/**
 * POJO representing all relevant access information for a dataset version's blob.
 */
public static class DatasetBlobAccessInfo {
    private final String blobUri;
    private final String storageAccountArmId;
    private final String sasUri;
    private final String credentialType;

    public DatasetBlobAccessInfo(String blobUri, String storageAccountArmId, String sasUri, String credentialType) {
        this.blobUri = blobUri;
        this.storageAccountArmId = storageAccountArmId;
        this.sasUri = sasUri;
        this.credentialType = credentialType;
    }

    public String getBlobUri() {
        return blobUri;
    }

    public String getStorageAccountArmId() {
        return storageAccountArmId;
    }

    public String getSasUri() {
        return sasUri;
    }

    public String getCredentialType() {
        return credentialType;
    }
}