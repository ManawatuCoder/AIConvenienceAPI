Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-14_22-13


/**
 * Lists all versions of the specified dataset, or only the latest version of each dataset, depending on the provided flag.
 *
 * @param name The name of the dataset resource. If null or empty, lists only the latest version of each dataset.
 * @param latestOnly If true, lists only the latest version of each dataset; if false, lists all versions of the specified dataset.
 * @return A paged collection of DatasetVersion items.
 */
public PagedIterable<DatasetVersion> listDatasetVersions(String name, boolean latestOnly) {
    /*
      Combined Methods: listDatasetVersions, listLatestDatasetVersions
      Reason: Developers often want to either list all versions of a dataset or just the latest version(s). This wrapper provides a single, intent-revealing entry point that eliminates the need for the user to remember or discover two separate methods, and handles the common "latest only" scenario with a simple flag.
    */
    if (latestOnly) {
        return listLatestDatasetVersions();
    } else {
        return listDatasetVersions(name);
    }
}

/**
 * Lists all versions of the specified dataset.
 *
 * @param name The name of the dataset resource.
 * @return A paged collection of DatasetVersion items.
 */
public PagedIterable<DatasetVersion> listAllDatasetVersions(String name) {
    /*
      Combined Methods: listDatasetVersions
      Reason: Provides a more discoverable and intent-revealing method name for the common scenario of listing all versions, aligning with Java naming conventions and reducing ambiguity for new users.
    */
    return listDatasetVersions(name);
}

/**
 * Lists only the latest version of each dataset.
 *
 * @return A paged collection of DatasetVersion items.
 */
public PagedIterable<DatasetVersion> listAllLatestDatasetVersions() {
    /*
      Combined Methods: listLatestDatasetVersions
      Reason: Provides a more explicit and discoverable method name for listing only the latest versions, making the API more intuitive for developers who are interested in the most recent data.
    */
    return listLatestDatasetVersions();
}/**
 * Retrieves a specific version of the DatasetVersion, with sensible defaults for request options.
 * <p>
 * This method streamlines the process of fetching a DatasetVersion by automatically applying default request options,
 * eliminating the need for users to manually construct a RequestOptions instance for the common case.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to retrieve.
 * @return the specific version of the DatasetVersion.
 */
public DatasetVersion getDatasetVersion(String name, String version) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Most users want the DatasetVersion object directly and do not need to construct or pass RequestOptions.
      This wrapper provides a streamlined experience for the common case, applying sensible defaults and returning the logical entity.
    */
    RequestOptions requestOptions = new RequestOptions();
    return getDatasetVersionWithResponse(name, version, requestOptions)
        .getValue()
        .toObject(DatasetVersion.class);
}

/**
 * Retrieves a specific version of the DatasetVersion, returning the full HTTP response including headers and status.
 * <p>
 * This method provides advanced users access to the complete HTTP response, while still applying sensible defaults for request options.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to retrieve.
 * @return the HTTP response containing the specific version of the DatasetVersion.
 */
public Response<BinaryData> getDatasetVersionWithResponse(String name, String version) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Many users want the full HTTP response but do not need to customize RequestOptions.
      This wrapper eliminates the need to manually construct a RequestOptions instance for the common case.
    */
    RequestOptions requestOptions = new RequestOptions();
    return getDatasetVersionWithResponse(name, version, requestOptions);
}/**
 * Creates or updates a dataset version from a local file or folder path.
 * <p>
 * This method automatically detects whether the provided path is a file or a directory,
 * and uploads the content as a file or folder dataset version accordingly.
 * It streamlines the workflow by handling validation, pending upload, upload, and dataset registration steps.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or replace.
 * @param path The path to the file or folder to upload.
 * @return The created FileDatasetVersion or FolderDatasetVersion, depending on the input path.
 * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
 * @throws IOException If an I/O error is thrown when accessing the file system.
 */
public Object upsertDatasetVersionFromPath(String name, String version, Path path) throws IOException {
    /*
      Combined Methods: createDatasetWithFile, createDatasetWithFolder, pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper improves developer experience by providing a single entry point for the common workflow of uploading either a file or a folder as a dataset version. It eliminates the need for the developer to manually distinguish between file and folder uploads, reduces repetitive validation and setup, and encapsulates the multi-step process into a single, intent-driven call.
    */
    if (Files.isRegularFile(path)) {
        // File upload path
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(path));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    } else if (Files.isDirectory(path)) {
        // Folder upload path
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(path).filter(Files::isRegularFile).forEach(filePath -> {
            String relativePath = path.relativize(filePath).toString().replace('\\', '/');
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    } else {
        throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
    }
}/**
 * Starts or retrieves a pending upload for a dataset version with minimal required parameters.
 * <p>
 * This convenience method allows developers to initiate a pending upload of a dataset version,
 * specifying only the dataset name and version. It automatically creates a PendingUploadRequest
 * with the required pendingUploadType set to "BlobReference", and uses default request options.
 * </p>
 */
public PendingUploadResponse startPendingUpload(String name, String version) {
    /*
      Combined Methods: pendingUpload(String, String, PendingUploadRequest)
      Reason: Simplifies the most common workflow by auto-constructing the minimal PendingUploadRequest
              for a BlobReference upload, reducing boilerplate and parameter redundancy for users who
              only need to start a standard pending upload.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType("BlobReference");
    return pendingUpload(name, version, request);
}

/**
 * Starts or retrieves a pending upload for a dataset version, specifying the connection name.
 * <p>
 * This convenience method allows developers to initiate a pending upload of a dataset version,
 * specifying the dataset name, version, and connection name. It automatically creates a PendingUploadRequest
 * with the required pendingUploadType set to "BlobReference", and uses default request options.
 * </p>
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param connectionName The name of the storage connection to use.
 */
public PendingUploadResponse startPendingUpload(String name, String version, String connectionName) {
    /*
      Combined Methods: pendingUpload(String, String, PendingUploadRequest)
      Reason: Reduces friction for the common scenario where a user needs to specify a connection name,
              but otherwise wants the defaults for a BlobReference upload. This avoids manual construction
              of the PendingUploadRequest and repetitive setting of the required type.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType("BlobReference")
        .setConnectionName(connectionName);
    return pendingUpload(name, version, request);
}

/**
 * Starts or retrieves a pending upload for a dataset version with a specified pending upload type.
 * <p>
 * This convenience method allows developers to initiate a pending upload of a dataset version,
 * specifying the dataset name, version, and pending upload type (e.g., "BlobReference" or "None").
 * It uses default request options.
 * </p>
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload ("BlobReference" or "None").
 */
public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType) {
    /*
      Combined Methods: pendingUpload(String, String, PendingUploadRequest)
      Reason: Enables users to easily specify the pending upload type without constructing a request object,
              streamlining scenarios where the type is the only customization needed.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType(pendingUploadType);
    return pendingUpload(name, version, request);
}/**
 * Creates or updates a DatasetVersion with the given required parameters, using sensible defaults for optional fields.
 * <p>
 * This overload streamlines the creation or update of a DatasetVersion by requiring only the most common parameters:
 * type, name, version, and dataUri. All other fields are optional and set to null or empty values.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(String type, String name, String version, String dataUri) {
    /*
      Combined Methods: createOrUpdateDatasetVersion
      Reason: Developers frequently want to create or update a DatasetVersion with just the required fields.
      This wrapper reduces boilerplate by constructing the DatasetVersion model with sensible defaults for optional fields,
      enabling a quick and error-free workflow for the most common scenario.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setType(type)
        .setName(name)
        .setVersion(version)
        .setDataUri(dataUri);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with common optional fields, providing a streamlined overload for typical use cases.
 * <p>
 * This overload allows the developer to specify type, name, version, dataUri, description, and tags,
 * while omitting less commonly used fields. All other fields are set to null or empty values.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(
    String type,
    String name,
    String version,
    String dataUri,
    String description,
    Map<String, String> tags
) {
    /*
      Combined Methods: createOrUpdateDatasetVersion
      Reason: Many developers want to set description and tags in addition to the required fields.
      This wrapper reduces boilerplate by allowing these common optional fields to be set directly,
      while hiding less commonly used fields and setup logic.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setType(type)
        .setName(name)
        .setVersion(version)
        .setDataUri(dataUri)
        .setDescription(description)
        .setTags(tags);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with all available fields, using a fluent options pattern for clarity and future extensibility.
 * <p>
 * This overload accepts an UpsertDatasetVersionOptions object, allowing the developer to specify any combination of fields,
 * and forwards the call to the underlying service method.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(UpsertDatasetVersionOptions options) {
    /*
      Combined Methods: createOrUpdateDatasetVersion
      Reason: The options pattern enables extensibility and clarity for complex scenarios,
      allowing developers to specify only the fields they care about in a fluent, discoverable way.
      This wrapper aligns with Azure SDK guidelines for complex service methods.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setType(options.getType())
        .setName(options.getName())
        .setVersion(options.getVersion())
        .setDataUri(options.getDataUri())
        .setIsReference(options.isReference())
        .setConnectionName(options.getConnectionName())
        .setId(options.getId())
        .setDescription(options.getDescription())
        .setTags(options.getTags());
    return createOrUpdateDatasetVersion(options.getName(), options.getVersion(), datasetVersion);
}/**
 * Deletes all versions of the specified Dataset.
 * <p>
 * This method retrieves all versions for the given dataset name and deletes each version sequentially.
 * It simplifies the process of cleaning up all dataset versions without requiring the developer to enumerate and delete each version individually.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @throws IllegalArgumentException thrown if parameters fail the validation.
 * @throws HttpResponseException thrown if a delete request is rejected by server.
 * @throws ClientAuthenticationException thrown if a delete request is rejected by server on status code 401.
 * @throws ResourceNotFoundException thrown if a delete request is rejected by server on status code 404.
 * @throws ResourceModifiedException thrown if a delete request is rejected by server on status code 409.
 * @throws RuntimeException all other wrapped checked exceptions if a request fails to be sent.
 */
public void deleteAllDatasetVersions(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Developers often want to delete all versions of a dataset as a single operation, but currently must enumerate and delete each version manually. This wrapper automates the workflow, reducing boilerplate and risk of partial cleanup.
    */
    // Assume listDatasetVersions returns a list of version identifiers for the dataset.
    List<String> versions = listDatasetVersions(name);
    for (String version : versions) {
        deleteDatasetVersion(name, version);
    }
}

/**
 * Deletes the specified version of the Dataset and ignores ResourceNotFoundException.
 * <p>
 * This method deletes a dataset version, but suppresses errors if the version does not exist.
 * Useful for idempotent cleanup scenarios where absence of the resource is not an error.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The version of the DatasetVersion to delete.
 */
public void deleteDatasetVersionIfExists(String name, String version) {
    /*
      Combined Methods: deleteDatasetVersion
      Reason: Developers may want to ensure a dataset version is deleted, but not fail if it is already absent. This wrapper provides a more robust, idempotent delete operation for common cleanup scenarios.
    */
    try {
        deleteDatasetVersion(name, version);
    } catch (ResourceNotFoundException ex) {
        // Ignore if not found
    }
}/**
 * Retrieves the SAS URI for the blob associated with a given Dataset version.
 * <p>
 * This method simplifies the process of obtaining a ready-to-use SAS URI for the target blob, 
 * abstracting away the need to manually parse the credential structure.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return The SAS URI string for the blob associated with the Dataset version.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if there is a conflict.
 * @throws RuntimeException for other wrapped checked exceptions.
 */
public String getBlobSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers often need direct access to the SAS URI for a dataset blob. This wrapper eliminates the need for users to manually navigate the AssetCredentialResult and its nested structure, streamlining the common workflow of retrieving a SAS URI for blob access.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null 
        || result.getBlobReference() == null 
        || result.getBlobReference().getCredential() == null 
        || result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("SAS URI not found in credential result.");
    }
    return result.getBlobReference().getCredential().getSasUri();
}

/**
 * Retrieves the blob URI for the storage resource associated with a given Dataset version.
 * <p>
 * This method provides direct access to the blob URI, avoiding manual traversal of the credential result structure.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return The blob URI string for the Dataset version.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if there is a conflict.
 * @throws RuntimeException for other wrapped checked exceptions.
 */
public String getBlobUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers frequently need the direct URI to the blob resource. This wrapper avoids repetitive and error-prone extraction from the nested AssetCredentialResult, improving clarity and reducing boilerplate.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null 
        || result.getBlobReference() == null 
        || result.getBlobReference().getBlobUri() == null) {
        throw new IllegalStateException("Blob URI not found in credential result.");
    }
    return result.getBlobReference().getBlobUri();
}

/**
 * Retrieves both the blob URI and its SAS URI for a given Dataset version in a single call.
 * <p>
 * This method returns a pair of the blob URI and its corresponding SAS URI, streamlining scenarios where both are required for storage access.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return A {@code Map.Entry<String, String>} where the key is the blob URI and the value is the SAS URI.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if there is a conflict.
 * @throws RuntimeException for other wrapped checked exceptions.
 */
public java.util.Map.Entry<String, String> getBlobUriAndSas(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Many workflows require both the blob URI and its SAS URI together. This wrapper provides both in one call, reducing repetitive extraction logic and clarifying intent.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null 
        || result.getBlobReference() == null 
        || result.getBlobReference().getBlobUri() == null
        || result.getBlobReference().getCredential() == null
        || result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("Blob URI or SAS URI not found in credential result.");
    }
    return new java.util.AbstractMap.SimpleImmutableEntry<>(
        result.getBlobReference().getBlobUri(),
        result.getBlobReference().getCredential().getSasUri()
    );
}