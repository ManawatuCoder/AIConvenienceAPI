Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-07_00-25


/**
 * Combined Methods: create, createWithResponse
 * Reason: Both methods create a new container with the same required parameters, with one returning a Response wrapper. Wrapping them provides a single entry point with an option to retrieve the raw response, improving discoverability and reducing overload confusion.
 * 
 * Comment: Creates a new container under the specified account, optionally returning the full HTTP response.
 */
public BlobContainer createContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, BlobContainer blobContainer, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.createWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer, requestContext).getValue();
    } else {
        return this.serviceClient.create(subscriptionId, resourceGroupName, accountName, containerName, apiVersion,
            blobContainer);
    }
}

/**
 * Combined Methods: update, updateWithResponse
 * Reason: Both methods update container properties with the same parameters, with one returning a Response wrapper. Wrapping them allows the developer to choose whether to receive the full HTTP response or just the logical entity, enhancing convenience.
 * 
 * Comment: Updates container properties as specified in the request body, optionally returning the full HTTP response.
 */
public BlobContainer updateContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, BlobContainer blobContainer, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.updateWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer, requestContext).getValue();
    } else {
        return this.serviceClient.update(subscriptionId, resourceGroupName, accountName, containerName, apiVersion,
            blobContainer);
    }
}

/**
 * Combined Methods: delete, deleteWithResponse
 * Reason: Both methods delete a specified container, with one returning a Response wrapper. Wrapping them provides a single method for deletion with an option to retrieve the raw response, simplifying the API surface.
 * 
 * Comment: Deletes the specified container under its account, optionally returning the full HTTP response.
 */
public Void deleteContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.deleteWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, requestContext).getValue();
    } else {
        this.serviceClient.delete(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
        return null;
    }
}

/**
 * Combined Methods: get, getWithResponse
 * Reason: Both methods retrieve container properties, with one returning a Response wrapper. Wrapping them allows users to choose the level of detail they need, improving usability.
 * 
 * Comment: Gets properties of a specified container, optionally returning the full HTTP response.
 */
public BlobContainer getContainer(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.getWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, requestContext).getValue();
    } else {
        return this.serviceClient.get(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
    }
}

/**
 * Combined Methods: list, listWithResponse
 * Reason: Both methods list containers, with one returning a Response wrapper and additional filtering/paging options. Wrapping them allows for a unified listing interface, simplifying the developer experience.
 * 
 * Comment: Lists all containers under the specified account, optionally returning the full HTTP response and supporting filtering/paging.
 */
public ListContainerItems listContainers(String subscriptionId, String resourceGroupName, String accountName,
    String apiVersion, String maxpagesize, String filter, ListContainersInclude include, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.listWithResponse(subscriptionId, resourceGroupName, accountName, apiVersion,
            maxpagesize, filter, include, requestContext).getValue();
    } else {
        return this.serviceClient.list(subscriptionId, resourceGroupName, accountName, apiVersion);
    }
}

/**
 * Combined Methods: clearLegalHold, clearLegalHoldWithResponse
 * Reason: Both methods clear legal hold tags, with one returning a Response wrapper. Wrapping them provides a single entry point for this operation, reducing overload confusion.
 * 
 * Comment: Clears legal hold tags on a container, optionally returning the full HTTP response.
 */
public LegalHold clearLegalHoldTags(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, LegalHold legalHold, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.clearLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, legalHold, requestContext).getValue();
    } else {
        return this.serviceClient.clearLegalHold(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold);
    }
}

/**
 * Combined Methods: setLegalHold, setLegalHoldWithResponse
 * Reason: Both methods set legal hold tags, with one returning a Response wrapper. Wrapping them provides a single method for setting legal hold tags, improving discoverability.
 * 
 * Comment: Sets legal hold tags on a container, optionally returning the full HTTP response.
 */
public LegalHold setLegalHoldTags(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, LegalHold legalHold, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.setLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, legalHold, requestContext).getValue();
    } else {
        return this.serviceClient.setLegalHold(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold);
    }
}

/**
 * Combined Methods: getImmutabilityPolicy, getImmutabilityPolicyWithResponse
 * Reason: Both methods retrieve the immutability policy, with one returning a Response wrapper. Wrapping them allows the developer to choose the level of detail needed.
 * 
 * Comment: Gets the existing immutability policy for a container, optionally returning the full HTTP response.
 */
public ImmutabilityPolicy getImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.getImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, requestContext).getValue();
    } else {
        return this.serviceClient.getImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion);
    }
}

/**
 * Combined Methods: deleteImmutabilityPolicy, deleteImmutabilityPolicyWithResponse
 * Reason: Both methods delete the immutability policy, with one returning a Response wrapper. Wrapping them provides a single entry point for this operation, improving usability.
 * 
 * Comment: Deletes the immutability policy for a container, optionally returning the full HTTP response.
 */
public ImmutabilityPolicy deleteImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.deleteImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, requestContext).getValue();
    } else {
        return this.serviceClient.deleteImmutabilityPolicy(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch);
    }
}

/**
 * Combined Methods: lockImmutabilityPolicy, lockImmutabilityPolicyWithResponse
 * Reason: Both methods lock the immutability policy, with one returning a Response wrapper. Wrapping them provides a single method for this operation, reducing overload confusion.
 * 
 * Comment: Locks the immutability policy for a container, optionally returning the full HTTP response.
 */
public ImmutabilityPolicy lockImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.lockImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, requestContext).getValue();
    } else {
        return this.serviceClient.lockImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, ifMatch);
    }
}

/**
 * Combined Methods: createOrUpdateImmutabilityPolicy, createOrUpdateImmutabilityPolicyWithResponse
 * Reason: Both methods create or update the immutability policy, with one returning a Response wrapper. Wrapping them provides a unified interface for this operation.
 * 
 * Comment: Creates or updates the immutability policy for a container, optionally returning the full HTTP response.
 */
public ImmutabilityPolicy createOrUpdateImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, ImmutabilityPolicy parameters, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.createOrUpdateImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName,
            accountName, containerName, apiVersion, ifMatch, parameters, requestContext).getValue();
    } else {
        return this.serviceClient.createOrUpdateImmutabilityPolicy(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion);
    }
}

/**
 * Combined Methods: extendImmutabilityPolicy, extendImmutabilityPolicyWithResponse
 * Reason: Both methods extend the immutability policy, with one returning a Response wrapper. Wrapping them provides a single entry point for this operation, improving developer experience.
 * 
 * Comment: Extends the immutability period of a locked policy for a container, optionally returning the full HTTP response.
 */
public ImmutabilityPolicy extendImmutabilityPolicy(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, String ifMatch, ImmutabilityPolicy parameters, RequestContext requestContext, boolean withResponse) {
    if (withResponse) {
        return this.serviceClient.extendImmutabilityPolicyWithResponse(subscriptionId, resourceGroupName, accountName,
            containerName, apiVersion, ifMatch, parameters, requestContext).getValue();
    } else {
        return this.serviceClient.extendImmutabilityPolicy(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, ifMatch);
    }
}