Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-14_22-30


/**
 * Retrieves all versions of a dataset, sorted with the latest version first.
 *
 * <p>This method combines listing all dataset versions and sorting them so that the latest version appears first.
 * This is a common developer workflow when browsing or displaying dataset histories, and avoids the need for manual sorting.</p>
 */
public List<DatasetVersion> listAllDatasetVersionsLatestFirst(String name) {
    /*
      Combined Methods: listDatasetVersions
      Reason: Developers often want to view dataset version history with the latest version first. This wrapper retrieves all versions and sorts them by version descending, eliminating manual sorting boilerplate.
    */
    List<DatasetVersion> versions = new ArrayList<>();
    for (DatasetVersion version : listDatasetVersions(name)) {
        versions.add(version);
    }
    versions.sort(Comparator.comparing(DatasetVersion::getVersion).reversed());
    return versions;
}

/**
 * Retrieves the latest version of a dataset by name.
 *
 * <p>This method combines listing all versions and selecting the latest one, which is a common developer need.
 * It avoids the need for users to manually iterate and compare versions.</p>
 */
public Optional<DatasetVersion> getLatestDatasetVersion(String name) {
    /*
      Combined Methods: listDatasetVersions
      Reason: Developers frequently need just the latest version of a dataset. This wrapper fetches all versions and returns the one with the highest version, reducing boilerplate and potential errors.
    */
    return StreamSupport.stream(listDatasetVersions(name).spliterator(), false)
        .max(Comparator.comparing(DatasetVersion::getVersion));
}

/**
 * Retrieves all latest versions of all datasets.
 *
 * <p>This method wraps the listing of latest dataset versions and collects them into a list for easier consumption.</p>
 */
public List<DatasetVersion> listAllLatestDatasetVersions() {
    /*
      Combined Methods: listLatestDatasetVersions
      Reason: Developers often want a concrete list of the latest version for each dataset, rather than a paged iterable. This wrapper collects all items, simplifying iteration and further processing.
    */
    List<DatasetVersion> latestVersions = new ArrayList<>();
    for (DatasetVersion version : listLatestDatasetVersions()) {
        latestVersions.add(version);
    }
    return latestVersions;
}/**
 * Begins a new pending upload for a dataset version, or retrieves an existing one, using only the required parameters.
 * <p>
 * This convenience method streamlines the common scenario where only the dataset name, version, and pending upload type are needed,
 * providing sensible defaults for optional fields and reducing boilerplate.
 * </p>
 * 
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @return The pending upload response containing upload details.
 */
public PendingUploadResponse beginPendingUpload(String name, String version, String pendingUploadType) {
    /*
      Combined Methods: pendingUpload
      Reason: Developers typically want to initiate a pending upload with minimal required information. This wrapper reduces the need to manually construct a PendingUploadRequest for the most common case, eliminating repetitive setup and parameter boilerplate.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType(pendingUploadType);
    return pendingUpload(name, version, request);
}

/**
 * Begins a new pending upload for a dataset version, or retrieves an existing one, allowing optional connection name.
 * <p>
 * This convenience method streamlines the scenario where a developer may wish to specify a connection name, but does not need to set other optional fields.
 * </p>
 * 
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @param connectionName The name of the storage connection to use (optional).
 * @return The pending upload response containing upload details.
 */
public PendingUploadResponse beginPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
    /*
      Combined Methods: pendingUpload
      Reason: Developers often need to specify a connection name in addition to required fields. This wrapper eliminates the need to manually construct a PendingUploadRequest for this common scenario, improving clarity and reducing boilerplate.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType(pendingUploadType)
        .setConnectionName(connectionName);
    return pendingUpload(name, version, request);
}

/**
 * Begins or retrieves a pending upload for a dataset version, using only the required parameters, and returns the full HTTP response.
 * <p>
 * This overload provides access to HTTP response metadata for advanced scenarios, while still simplifying request construction for the common case.
 * </p>
 * 
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @param requestOptions The options to configure the HTTP request.
 * @return The HTTP response containing the pending upload details as a strongly-typed object.
 */
public Response<PendingUploadResponse> beginPendingUploadWithResponse(String name, String version, String pendingUploadType, RequestOptions requestOptions) {
    /*
      Combined Methods: pendingUploadWithResponse
      Reason: This wrapper reduces boilerplate for developers who need HTTP response metadata, but want to provide only the minimal required information for the upload request.
    */
    PendingUploadRequest request = new PendingUploadRequest()
        .setPendingUploadType(pendingUploadType);
    Response<BinaryData> response = pendingUploadWithResponse(name, version, BinaryData.fromObject(request), requestOptions);
    return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), response.getValue().toObject(PendingUploadResponse.class));
}/**
 * Retrieves the specific version of a DatasetVersion with sensible defaults and simplified usage.
 * <p>
 * This method streamlines the retrieval of a DatasetVersion by hiding the need for explicit RequestOptions construction,
 * and provides a single, clear entry point for the most common scenario: fetching a DatasetVersion by name and version.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to retrieve.
 * @return The specific version of the DatasetVersion.
 */
public DatasetVersion fetchDatasetVersion(String name, String version) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Eliminates the need for the user to manually construct RequestOptions for the common case,
      providing a more direct and idiomatic way to retrieve a DatasetVersion by name and version.
      This wrapper aligns with Azure SDK guidelines by offering a streamlined overload for the most typical workflow.
    */
    return getDatasetVersionWithResponse(name, version, new RequestOptions())
        .getValue()
        .toObject(DatasetVersion.class);
}

/**
 * Retrieves the specific version of a DatasetVersion, returning the full HTTP response for advanced scenarios.
 * <p>
 * This method provides a simplified overload for advanced users who want access to the full HTTP response,
 * but do not need to manually construct RequestOptions for the common case.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to retrieve.
 * @return The full HTTP response containing the DatasetVersion as BinaryData.
 */
public Response<BinaryData> fetchDatasetVersionWithResponse(String name, String version) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Removes repetitive boilerplate by supplying a default RequestOptions instance, 
      allowing users to access the full HTTP response without unnecessary setup for the common scenario.
      This improves clarity and reduces friction for advanced users.
    */
    return getDatasetVersionWithResponse(name, version, new RequestOptions());
}/**
 * Creates or updates a dataset version from a file or folder path, automatically detecting the type and handling upload.
 *
 * <p>
 * This method streamlines the process of creating or updating a dataset version by:
 * <ul>
 *   <li>Automatically determining whether the provided path is a file or a folder.</li>
 *   <li>Handling the upload process for both files and folders, including all necessary setup and validation.</li>
 *   <li>Reducing the need for the user to manually choose between file and folder upload APIs.</li>
 * </ul>
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to create or replace.
 * @param path The path to the file or folder containing data to upload.
 * @return The created dataset version, either FileDatasetVersion or FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
 * @throws IOException If an I/O error is thrown when accessing the file system.
 */
public Object upsertDatasetVersionFromPath(String name, String version, Path path) throws IOException {
    /*
      Combined Methods: createDatasetWithFile, createDatasetWithFolder
      Reason: Developers often want to create or update a dataset version from a local path without worrying about
      whether it's a file or folder. This wrapper automates detection and dispatch, reducing boilerplate and
      eliminating the need for manual branching and error-prone setup.
    */
    if (Files.isRegularFile(path)) {
        return createDatasetWithFile(name, version, path);
    } else if (Files.isDirectory(path)) {
        return createDatasetWithFolder(name, version, path);
    } else {
        throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
    }
}

/**
 * Creates or updates a dataset version from a file, with minimal parameters and sensible defaults.
 *
 * <p>
 * This method simplifies the process of uploading a file as a dataset version by:
 * <ul>
 *   <li>Validating the file path and handling all upload steps internally.</li>
 *   <li>Using default options for upload and dataset creation.</li>
 *   <li>Reducing the required parameters to only those essential for the operation.</li>
 * </ul>
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to create or replace.
 * @param filePath The path to the file to upload.
 * @return The created FileDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a file.
 */
public FileDatasetVersion upsertDatasetVersionFromFile(String name, String version, Path filePath) {
    /*
      Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: Developers frequently want to upload a single file as a dataset version without managing upload requests,
      credentials, or constructing intermediate objects. This wrapper hides those details and provides a streamlined,
      intent-driven API.
    */
    return createDatasetWithFile(name, version, filePath);
}

/**
 * Creates or updates a dataset version from a folder, with minimal parameters and sensible defaults.
 *
 * <p>
 * This method simplifies the process of uploading a folder as a dataset version by:
 * <ul>
 *   <li>Validating the folder path and handling recursive upload of all files.</li>
 *   <li>Using default options for upload and dataset creation.</li>
 *   <li>Reducing the required parameters to only those essential for the operation.</li>
 * </ul>
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to create or replace.
 * @param folderPath The path to the folder to upload.
 * @return The created FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a directory.
 * @throws IOException If an I/O error is thrown when accessing the file system.
 */
public FolderDatasetVersion upsertDatasetVersionFromFolder(String name, String version, Path folderPath) throws IOException {
    /*
      Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: Developers frequently want to upload a folder as a dataset version without managing upload requests,
      credentials, or constructing intermediate objects. This wrapper hides those details and provides a streamlined,
      intent-driven API.
    */
    return createDatasetWithFolder(name, version, folderPath);
}

/**
 * Creates or updates a dataset version from a data URI, with optional metadata.
 *
 * <p>
 * This method allows developers to create or update a dataset version by providing a data URI directly,
 * optionally specifying description and tags, and using sensible defaults for other parameters.
 * </p>
 *
 * @param name The name of the resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param dataUri The URI pointing to the data (file or folder).
 * @param type The type of dataset ("uri_file" or "uri_folder").
 * @param description Optional description for the dataset version.
 * @param tags Optional tags for the dataset version.
 * @return The created or updated dataset version as a logical entity.
 */
public Object upsertDatasetVersionFromUri(String name, String version, String dataUri, String type, String description, Map<String, String> tags) {
    /*
      Combined Methods: createOrUpdateDatasetVersionWithResponse
      Reason: Developers may want to register a dataset version from an existing URI, optionally adding metadata,
      without constructing a full DatasetVersion object or handling request options. This wrapper provides a concise,
      intent-driven API for this common scenario.
    */
    RequestOptions requestOptions = new RequestOptions();
    Object datasetVersion;
    if ("uri_file".equals(type)) {
        FileDatasetVersion fileVersion = new FileDatasetVersion()
            .setDataUri(dataUri)
            .setName(name)
            .setVersion(version)
            .setDescription(description)
            .setTags(tags);
        datasetVersion = this.createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(fileVersion), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
    } else if ("uri_folder".equals(type)) {
        FolderDatasetVersion folderVersion = new FolderDatasetVersion()
            .setDataUri(dataUri)
            .setName(name)
            .setVersion(version)
            .setDescription(description)
            .setTags(tags);
        datasetVersion = this.createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(folderVersion), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
    } else {
        throw new IllegalArgumentException("Unsupported dataset type: " + type);
    }
    return datasetVersion;
}/**
 * Deletes all versions of the specified Dataset.
 *
 * This method deletes all versions of a Dataset by enumerating all available versions and deleting each one.
 * It is useful for scenarios where a developer wants to ensure a Dataset is fully removed, regardless of how many versions exist.
 */
public void deleteAllDatasetVersions(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Developers often want to delete an entire Dataset, not just a single version. This wrapper automates the repetitive workflow of enumerating all versions and deleting them one by one, reducing boilerplate and the risk of missing versions.
    */
    List<String> versions = listDatasetVersions(name); // Assume this method exists and returns all version strings for the dataset
    for (String version : versions) {
        deleteDatasetVersion(name, version);
    }
}

/**
 * Deletes the latest version of the specified Dataset.
 *
 * This method finds and deletes the most recent version of a Dataset, simplifying the common task of cleaning up only the latest version.
 */
public void deleteLatestDatasetVersion(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Developers may often want to delete just the latest version of a Dataset. This wrapper hides the logic of identifying the latest version and performing the delete, streamlining a common workflow.
    */
    List<String> versions = listDatasetVersions(name); // Assume this method exists and returns all version strings for the dataset
    if (!versions.isEmpty()) {
        String latestVersion = Collections.max(versions); // Assumes version strings are comparable
        deleteDatasetVersion(name, latestVersion);
    }
}

/**
 * Deletes the specified version of a Dataset, suppressing ResourceNotFoundException if the version does not exist.
 *
 * This method is useful for idempotent delete scenarios where the developer does not care if the version is already deleted.
 *
 * @param name The name of the resource.
 * @param version The version of the DatasetVersion to delete.
 */
public void deleteDatasetVersionIfExists(String name, String version) {
    /*
      Combined Methods: deleteDatasetVersion
      Reason: Deleting resources idempotently is a common pattern. This wrapper suppresses errors when the resource is already deleted, reducing error handling boilerplate for the user.
    */
    try {
        deleteDatasetVersion(name, version);
    } catch (ResourceNotFoundException ex) {
        // Suppress, as the resource is already gone
    }
}/**
 * Creates or updates a DatasetVersion with the given required fields, providing a streamlined overload for the most common scenario.
 * <p>
 * This convenience method allows developers to create or update a DatasetVersion by specifying only the required parameters:
 * name, version, type, and dataUri. Optional fields such as description, tags, isReference, and connectionName are omitted for simplicity.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(String name, String version, String type, String dataUri) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: Developers frequently want to create or update a dataset version with only the required fields.
      This wrapper eliminates the need to manually construct a DatasetVersion object and set required properties,
      reducing boilerplate and potential errors. It aligns with the options pattern by providing a simple overload for the common case.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with all common fields, including optional description and tags.
 * <p>
 * This overload simplifies the creation or update of a DatasetVersion by allowing the caller to specify
 * the most commonly used fields directly, without manually constructing and populating a DatasetVersion object.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(
    String name,
    String version,
    String type,
    String dataUri,
    String description,
    Map<String, String> tags
) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: Developers often want to create or update a dataset version with both required and commonly-used optional fields.
      This wrapper reduces repetitive setup and improves clarity by exposing the most relevant parameters directly,
      while still allowing the full power of the underlying method for advanced scenarios.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri)
        .setDescription(description)
        .setTags(tags);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}/**
 * Retrieves the SAS URI for accessing the storage blob associated with a specific Dataset version.
 * <p>
 * This method abstracts away the details of extracting the SAS URI from the credential response,
 * providing direct access to the blob's SAS URI for common scenarios such as downloading or uploading data.
 * </p>
 *
 * @param name The name of the Dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return The SAS URI string for the storage blob associated with the Dataset version.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by server.
 * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
 * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
 * @throws ResourceModifiedException if the request is rejected by server on status code 409.
 * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
 */
public String getDatasetVersionBlobSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers frequently need the SAS URI to access the dataset blob directly. This wrapper eliminates the need to manually navigate the AssetCredentialResult structure, streamlining a common workflow and reducing boilerplate code.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null ||
        result.getBlobReference().getCredential() == null ||
        result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("SAS URI not found in credential response.");
    }
    return result.getBlobReference().getCredential().getSasUri();
}


/**
 * Retrieves the storage blob URI and its associated SAS credential for a specific Dataset version as a simple pair.
 * <p>
 * This method provides both the blob URI and the SAS URI together, making it easier for developers to access or reference both endpoints without parsing nested result objects.
 * </p>
 *
 * @param name The name of the Dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @return A simple two-element array: [0] = blobUri, [1] = sasUri.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by server.
 * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
 * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
 * @throws ResourceModifiedException if the request is rejected by server on status code 409.
 * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
 */
public String[] getDatasetVersionBlobUris(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers often need both the blob URI and its SAS credential together for storage operations. This wrapper provides a concise, direct way to obtain both values, avoiding repetitive extraction logic and improving clarity for common integration scenarios.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null ||
        result.getBlobReference().getCredential() == null ||
        result.getBlobReference().getCredential().getSasUri() == null ||
        result.getBlobReference().getBlobUri() == null) {
        throw new IllegalStateException("Blob URI or SAS URI not found in credential response.");
    }
    return new String[] {
        result.getBlobReference().getBlobUri(),
        result.getBlobReference().getCredential().getSasUri()
    };
}