Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-06_22-05


/**
 * Combined Methods: setLegalHold, setLegalHoldWithResponse
 * Reason: Both methods perform the same operation of setting legal hold tags, with one returning a simple result and the other returning a Response wrapper. Providing a single wrapper method that chooses the overload based on the presence of a RequestContext parameter streamlines the developer experience and reduces overload confusion.
 * 
 * Comment: Sets legal hold tags on a blob container, optionally returning the full HTTP response if a RequestContext is provided.
 */
public Response<LegalHold> setLegalHoldUnified(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, LegalHold legalHold, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.setLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold, requestContext);
    } else {
        LegalHold result = this.serviceClient.setLegalHold(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold);
        return new SimpleResponse<>(null, 200, null, result);
    }
}

/**
 * Combined Methods: clearLegalHold, clearLegalHoldWithResponse
 * Reason: Both methods clear legal hold tags, with one returning a simple result and the other returning a Response wrapper. Wrapping them together allows the user to choose the overload based on whether they need the HTTP response, improving usability.
 * 
 * Comment: Clears legal hold tags from a blob container, optionally returning the full HTTP response if a RequestContext is provided.
 */
public Response<LegalHold> clearLegalHoldUnified(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, LegalHold legalHold, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.clearLegalHoldWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold, requestContext);
    } else {
        LegalHold result = this.serviceClient.clearLegalHold(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, legalHold);
        return new SimpleResponse<>(null, 200, null, result);
    }
}

/**
 * Combined Methods: create, createWithResponse
 * Reason: Both methods create a new container, with one returning the logical entity and the other returning a Response wrapper. Providing a unified wrapper allows developers to use a single entry point for both scenarios, reducing overload complexity.
 * 
 * Comment: Creates a new blob container under the specified account, optionally returning the full HTTP response if a RequestContext is provided.
 */
public Response<BlobContainer> createContainerUnified(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, BlobContainer blobContainer, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.createWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer, requestContext);
    } else {
        BlobContainer result = this.serviceClient.create(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer);
        return new SimpleResponse<>(null, 200, null, result);
    }
}

/**
 * Combined Methods: update, updateWithResponse
 * Reason: Both methods update container properties, with one returning the logical entity and the other returning a Response wrapper. Providing a unified wrapper method allows developers to use a single method for both scenarios, improving discoverability and reducing overload confusion.
 * 
 * Comment: Updates properties of a blob container, optionally returning the full HTTP response if a RequestContext is provided.
 */
public Response<BlobContainer> updateContainerUnified(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, BlobContainer blobContainer, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.updateWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer, requestContext);
    } else {
        BlobContainer result = this.serviceClient.update(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, blobContainer);
        return new SimpleResponse<>(null, 200, null, result);
    }
}

/**
 * Combined Methods: get, getWithResponse
 * Reason: Both methods retrieve container properties, with one returning the logical entity and the other returning a Response wrapper. Wrapping them together provides a single, convenient entry point for both usage patterns.
 * 
 * Comment: Gets properties of a specified blob container, optionally returning the full HTTP response if a RequestContext is provided.
 */
public Response<BlobContainer> getContainerUnified(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.getWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, requestContext);
    } else {
        BlobContainer result = this.serviceClient.get(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion);
        return new SimpleResponse<>(null, 200, null, result);
    }
}

/**
 * Combined Methods: delete, deleteWithResponse
 * Reason: Both methods delete a container, with one returning void and the other returning a Response wrapper. Providing a unified wrapper allows developers to use a single method for both scenarios, improving usability and reducing overload confusion.
 * 
 * Comment: Deletes a specified blob container, optionally returning the full HTTP response if a RequestContext is provided.
 */
public Response<Void> deleteContainerUnified(String subscriptionId, String resourceGroupName, String accountName,
    String containerName, String apiVersion, RequestContext requestContext) {
    if (requestContext != null) {
        return this.serviceClient.deleteWithResponse(subscriptionId, resourceGroupName, accountName, containerName,
            apiVersion, requestContext);
    } else {
        this.serviceClient.delete(subscriptionId, resourceGroupName, accountName, containerName, apiVersion);
        return new SimpleResponse<>(null, 200, null, null);
    }
}