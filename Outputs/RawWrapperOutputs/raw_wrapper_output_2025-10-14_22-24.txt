Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-14_22-24


/**
 * Retrieves all versions of the specified dataset, or just the latest version if requested.
 * Simplifies the workflow of listing dataset versions by providing a single entry point for both common scenarios.
 *
 * @param name The name of the dataset resource.
 * @param latestOnly If true, returns only the latest version of each dataset; if false, returns all versions.
 * @return Paged collection of DatasetVersion items as a {@link PagedIterable}.
 */
public PagedIterable<DatasetVersion> listDatasetVersions(String name, boolean latestOnly) {
    /*
      Combined Methods: listDatasetVersions, listLatestDatasetVersions
      Reason: Developers often want either all versions or just the latest version of a dataset. This wrapper provides a single, intent-driven entry point, reducing the need for developers to discover and choose between two similar methods. It streamlines the API surface and aligns with common developer workflows.
    */
    if (latestOnly) {
        return listLatestDatasetVersions();
    } else {
        return listDatasetVersions(name);
    }
}/**
 * Retrieves a specific version of a DatasetVersion, providing sensible defaults for request options.
 * This overload streamlines the common scenario where only the resource name and version are required.
 */
public DatasetVersion getDatasetVersion(String name, String version) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Provides a streamlined overload for the common case, hiding RequestOptions boilerplate and returning the logical entity directly, as per Azure SDK guidelines.
    */
    RequestOptions requestOptions = new RequestOptions();
    return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
}

/**
 * Retrieves a specific version of a DatasetVersion and returns the logical entity along with the full HTTP response.
 * This overload allows advanced users to specify custom request options.
 */
public Response<DatasetVersion> getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Improves developer experience by returning a strongly-typed logical entity (DatasetVersion) in the Response, eliminating the need for manual deserialization from BinaryData.
    */
    Response<BinaryData> response = getDatasetVersionWithResponse(name, version, requestOptions);
    DatasetVersion datasetVersion = response.getValue().toObject(DatasetVersion.class);
    return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), datasetVersion);
}/**
 * Creates or updates a dataset version from a file or folder, automatically detecting the type and handling upload.
 *
 * <p>
 * This method simplifies dataset creation by handling both file and folder sources, managing pending upload requests,
 * uploading content, and registering the dataset version. It eliminates the need for the developer to manually check
 * file/folder types, perform multi-step upload logic, or construct request payloads.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param path The path to the file or folder to upload.
 * @return The created dataset version as either FileDatasetVersion or FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
 * @throws IOException If an I/O error occurs when accessing the file system.
 */
public Object createOrUpdateDatasetVersion(String name, String version, Path path) throws IOException {
    /*
      Combined Methods: createDatasetWithFile, createDatasetWithFolder, pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper abstracts the repetitive and error-prone logic of distinguishing between file and folder uploads,
      managing pending upload requests, uploading content, and registering the dataset version. It enables a single, intent-driven
      method for the common workflow of dataset version creation from local sources, reducing boilerplate and potential for error.
    */
    if (Files.isRegularFile(path)) {
        // File upload workflow
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(path));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    } else if (Files.isDirectory(path)) {
        // Folder upload workflow
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(path).filter(Files::isRegularFile).forEach(filePath -> {
            String relativePath = path.relativize(filePath).toString().replace('\\', '/');
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    } else {
        throw new IllegalArgumentException("The provided path is neither a file nor a folder: " + path);
    }
}

/**
 * Creates or updates a dataset version from a file, with sensible defaults for common scenarios.
 *
 * <p>
 * This method streamlines the process of uploading a file as a dataset version by handling pending upload requests,
 * blob upload, and dataset registration with minimal required parameters.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param filePath The path to the file to upload.
 * @return The created FileDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a file.
 */
public FileDatasetVersion createDatasetVersionFromFile(String name, String version, Path filePath) {
    /*
      Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper eliminates repetitive setup for file-based dataset version creation, providing a clear,
      intent-driven method for the most common file upload scenario.
    */
    if (!Files.isRegularFile(filePath)) {
        throw new IllegalArgumentException("The provided path is not a file: " + filePath);
    }
    PendingUploadRequest body = new PendingUploadRequest();
    PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
    SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
    String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
    BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
    blobClient.upload(BinaryData.fromFile(filePath));
    RequestOptions requestOptions = new RequestOptions();
    FileDatasetVersion datasetVersion = this
        .createOrUpdateDatasetVersionWithResponse(name, version,
            BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
        .getValue()
        .toObject(FileDatasetVersion.class);
    return datasetVersion;
}

/**
 * Creates or updates a dataset version from a folder, with sensible defaults for common scenarios.
 *
 * <p>
 * This method streamlines the process of uploading a folder as a dataset version by handling pending upload requests,
 * recursive file upload, and dataset registration with minimal required parameters.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param folderPath The path to the folder to upload.
 * @return The created FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a directory.
 * @throws IOException If an I/O error occurs when accessing the file system.
 */
public FolderDatasetVersion createDatasetVersionFromFolder(String name, String version, Path folderPath) throws IOException {
    /*
      Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper eliminates repetitive setup for folder-based dataset version creation, providing a clear,
      intent-driven method for the most common folder upload scenario.
    */
    if (!Files.isDirectory(folderPath)) {
        throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
    }
    PendingUploadRequest request = new PendingUploadRequest();
    PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
    String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
    SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
    String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
    Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
        String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
        BlobClient blobClient
            = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath), true);
    });
    RequestOptions requestOptions = new RequestOptions();
    FolderDatasetVersion datasetVersion = this
        .createOrUpdateDatasetVersionWithResponse(name, version,
            BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
        .getValue()
        .toObject(FolderDatasetVersion.class);
    return datasetVersion;
}/**
 * Starts a new pending upload or retrieves an existing one for a dataset version, using only required parameters and sensible defaults.
 * <p>
 * This method simplifies the process of initiating a pending upload for the most common scenario,
 * requiring only the dataset name, version, and the required pending upload type.
 * Optional parameters such as pendingUploadId and connectionName are omitted for simplicity.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @return The response for the pending upload request.
 */
public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType) {
    /*
      Combined Methods: pendingUpload
      Reason: Provides a streamlined overload for the most common workflow, reducing boilerplate by
      allowing the developer to specify only the required fields. This eliminates the need to manually
      construct a PendingUploadRequest for the simple case, improving clarity and reducing friction.
    */
    PendingUploadRequest request = new PendingUploadRequest();
    request.setPendingUploadType(pendingUploadType);
    return pendingUpload(name, version, request);
}

/**
 * Starts a new pending upload or retrieves an existing one for a dataset version, allowing the caller to specify a connection name.
 * <p>
 * This method simplifies the process of initiating a pending upload for scenarios where a connection name is commonly used,
 * requiring only the dataset name, version, pending upload type, and connection name.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @param connectionName The name of the connection to use for the upload.
 * @return The response for the pending upload request.
 */
public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
    /*
      Combined Methods: pendingUpload
      Reason: Reduces boilerplate for a common scenario where a connection name is specified, letting developers avoid manual construction of the request object.
    */
    PendingUploadRequest request = new PendingUploadRequest();
    request.setPendingUploadType(pendingUploadType);
    request.setConnectionName(connectionName);
    return pendingUpload(name, version, request);
}

/**
 * Starts or retrieves a pending upload for a dataset version, specifying all commonly-used parameters.
 * <p>
 * This method provides a streamlined overload for the scenario where a pending upload ID is reused (e.g., for resuming uploads),
 * in addition to specifying the connection name and upload type.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @param connectionName The name of the connection to use for the upload.
 * @param pendingUploadId The ID of an existing pending upload to resume, or null to start a new one.
 * @return The response for the pending upload request.
 */
public PendingUploadResponse startOrResumePendingUpload(String name, String version, String pendingUploadType, String connectionName, String pendingUploadId) {
    /*
      Combined Methods: pendingUpload
      Reason: Provides a clear, intent-driven method for resuming or starting uploads, reducing manual request object setup and clarifying the workflow for resuming uploads.
    */
    PendingUploadRequest request = new PendingUploadRequest();
    request.setPendingUploadType(pendingUploadType);
    request.setConnectionName(connectionName);
    request.setPendingUploadId(pendingUploadId);
    return pendingUpload(name, version, request);
}/**
 * Creates or updates a DatasetVersion with the given name and version, using only the required parameters.
 * <p>
 * This overload provides a streamlined way to upsert a DatasetVersion when only the required fields are needed.
 * Optional fields (description, tags, etc.) can be set on the DatasetVersion model before passing it in.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(String name, String version, String type, String dataUri) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: Developers commonly want to quickly create or update a DatasetVersion with minimal required information.
      This wrapper reduces boilerplate by constructing the DatasetVersion model with required fields, allowing
      for a fast-path upsert scenario. Optional fields can be set by the developer on the returned object if needed.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with the given name and version, including optional description and tags.
 * <p>
 * This overload simplifies the common scenario where a developer wants to upsert a DatasetVersion and also
 * provide a description and tags, without manually constructing the DatasetVersion model.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(
    String name,
    String version,
    String type,
    String dataUri,
    String description,
    Map<String, String> tags
) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: Developers often want to specify description and tags when creating or updating a DatasetVersion.
      This wrapper reduces repetitive model construction and parameter mapping, improving clarity and usability.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri)
        .setDescription(description)
        .setTags(tags);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with all available options, using a builder-style options parameter.
 * <p>
 * This overload enables future extensibility and aligns with the Azure SDK options pattern, allowing
 * developers to fluently specify only the fields they care about.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(UpsertDatasetVersionOptions options) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: This wrapper introduces an options parameter pattern for extensibility and fluent usage, reducing
      the need for multiple overloads as the DatasetVersion model evolves. It aligns with Azure SDK guidelines
      for complex inputs and future-proofs the API surface.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(options.getName())
        .setVersion(options.getVersion())
        .setType(options.getType())
        .setDataUri(options.getDataUri())
        .setIsReference(options.isReference())
        .setConnectionName(options.getConnectionName())
        .setDescription(options.getDescription())
        .setTags(options.getTags());
    return createOrUpdateDatasetVersion(options.getName(), options.getVersion(), datasetVersion);
}/**
 * Deletes all versions of a dataset with the given name.
 * <p>
 * This method finds and deletes all versions of the specified dataset, handling common error scenarios.
 * </p>
 *
 * @param name The name of the dataset whose versions are to be deleted.
 * @throws IllegalArgumentException if the name is null or empty.
 * @throws RuntimeException if any delete operation fails.
 */
public void deleteAllDatasetVersions(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Developers often want to clean up all versions of a dataset. This wrapper automates the repetitive pattern of listing all versions and deleting them one by one, handling errors and reducing boilerplate.
    */
    if (name == null || name.isEmpty()) {
        throw new IllegalArgumentException("Dataset name cannot be null or empty.");
    }
    // Assume listDatasetVersions returns a List<DatasetVersion> or similar
    List<DatasetVersion> versions = listDatasetVersions(name);
    for (DatasetVersion version : versions) {
        try {
            deleteDatasetVersion(name, version.getVersion());
        } catch (ResourceNotFoundException ex) {
            // Already deleted, skip
        } catch (Exception ex) {
            throw new RuntimeException("Failed to delete dataset version: " + version.getVersion(), ex);
        }
    }
}

/**
 * Deletes the latest version of a dataset.
 * <p>
 * This method finds the most recent version of the specified dataset and deletes it.
 * </p>
 *
 * @param name The name of the dataset.
 * @throws IllegalArgumentException if the name is null or empty.
 * @throws ResourceNotFoundException if no versions exist.
 * @throws RuntimeException if the delete operation fails.
 */
public void deleteLatestDatasetVersion(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Deleting the latest version is a common workflow. This wrapper encapsulates the logic to find the latest version and delete it, reducing error-prone manual steps.
    */
    if (name == null || name.isEmpty()) {
        throw new IllegalArgumentException("Dataset name cannot be null or empty.");
    }
    List<DatasetVersion> versions = listDatasetVersions(name);
    if (versions.isEmpty()) {
        throw new ResourceNotFoundException("No versions found for dataset: " + name);
    }
    // Assume versions are sorted by version string or timestamp descending
    DatasetVersion latest = versions.get(0);
    deleteDatasetVersion(name, latest.getVersion());
}

/**
 * Deletes a dataset version if it exists, suppressing ResourceNotFoundException.
 * <p>
 * This method attempts to delete a dataset version, but does not throw if the version does not exist.
 * </p>
 *
 * @param name The name of the dataset.
 * @param version The version to delete.
 * @throws IllegalArgumentException if parameters are invalid.
 * @throws RuntimeException if the delete operation fails for reasons other than not found.
 */
public void deleteDatasetVersionIfExists(String name, String version) {
    /*
      Combined Methods: deleteDatasetVersion
      Reason: Developers often want idempotent deletes. This wrapper suppresses errors if the version does not exist, aligning with common "delete if exists" semantics.
    */
    try {
        deleteDatasetVersion(name, version);
    } catch (ResourceNotFoundException ex) {
        // Ignore, as the intent is to ensure deletion
    }
}/**
 * Retrieves the SAS credential URI for the storage account associated with a specific Dataset version.
 * <p>
 * This method simplifies access to the SAS URI by extracting it directly from the credential response,
 * allowing developers to quickly obtain the URI needed for storage operations without manually parsing
 * the full credential result.
 * </p>
 *
 * @param name The name of the Dataset resource.
 * @param version The version identifier of the Dataset.
 * @return The SAS URI string for accessing the storage account blob.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if the resource is in a conflict state.
 * @throws RuntimeException for other request failures.
 */
public String getDatasetVersionSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers commonly need just the SAS URI to access storage, not the full credential object.
      This wrapper eliminates the need for manual parsing of the AssetCredentialResult, streamlining the
      workflow for storage access and reducing boilerplate.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null
        || result.getBlobReference().getCredential() == null
        || result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("SAS URI could not be retrieved from the credential result.");
    }
    return result.getBlobReference().getCredential().getSasUri();
}

/**
 * Retrieves the storage account blob URI and its associated SAS credential for a specific Dataset version.
 * <p>
 * This method provides both the blob URI and the SAS token together, which are typically required together
 * for performing authenticated storage operations. It reduces the need for manual extraction from the
 * credential result and provides a clear, intent-driven API for storage access.
 * </p>
 *
 * @param name The name of the Dataset resource.
 * @param version The version identifier of the Dataset.
 * @return A simple pair containing the blob URI and the SAS URI.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if the resource is in a conflict state.
 * @throws RuntimeException for other request failures.
 */
public java.util.AbstractMap.SimpleEntry<String, String> getDatasetVersionBlobAndSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Accessing a storage blob typically requires both the blob URI and its SAS credential.
      This wrapper provides both in a single call, reducing repetitive extraction logic and clarifying
      developer intent for common storage access scenarios.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null
        || result.getBlobReference().getCredential() == null
        || result.getBlobReference().getBlobUri() == null
        || result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("Blob URI or SAS URI could not be retrieved from the credential result.");
    }
    return new java.util.AbstractMap.SimpleEntry<>(
        result.getBlobReference().getBlobUri(),
        result.getBlobReference().getCredential().getSasUri()
    );
}