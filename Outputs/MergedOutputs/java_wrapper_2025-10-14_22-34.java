// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Returns the latest version of the specified dataset, or null if no versions exist.
     *
     * <p>This method simplifies the common workflow of retrieving the most recent version of a dataset,
     * eliminating the need for the developer to manually list, sort, or filter versions.</p>
     *
     * @param name The name of the dataset resource.
     * @return The latest {@link DatasetVersion} for the given dataset, or null if none exist.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public DatasetVersion getLatestDatasetVersion(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Developers frequently need the latest version of a dataset. This wrapper hides the paging and manual selection logic, returning the latest version directly and reducing boilerplate.
        */
        PagedIterable<DatasetVersion> versions = listDatasetVersions(name);
        DatasetVersion latest = null;
        for (DatasetVersion version : versions) {
            if (latest == null || version.getVersion().compareTo(latest.getVersion()) > 0) {
                latest = version;
            }
        }
        return latest;
    }
    
    /**
     * Returns a map of dataset names to their latest version.
     *
     * <p>This method streamlines the process of retrieving the latest version for each dataset,
     * allowing developers to work directly with a convenient mapping, rather than iterating and filtering themselves.</p>
     *
     * @return A map where the key is the dataset name and the value is the latest {@link DatasetVersion}.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public Map<String, DatasetVersion> listLatestDatasetVersionsAsMap() {
        /*
          Combined Methods: listLatestDatasetVersions
          Reason: Developers often need a quick lookup of the latest version per dataset. This wrapper provides a ready-to-use map, eliminating the need for manual iteration and mapping.
        */
        Map<String, DatasetVersion> result = new HashMap<>();
        for (DatasetVersion version : listLatestDatasetVersions()) {
            result.put(version.getName(), version);
        }
        return result;
    }/**
     * Retrieves the latest version of a DatasetVersion by name.
     *
     * <p>This convenience method abstracts the process of determining the latest version of a dataset,
     * which typically requires listing all versions and selecting the most recent. This method assumes
     * that the service provides a way to determine or retrieve the latest version, or that the client
     * can infer it from available metadata. If not, this method can be extended to perform the necessary
     * logic using available APIs.</p>
     *
     * @param name The name of the dataset resource.
     * @return The latest version of the DatasetVersion, or null if none exist.
     */
    public DatasetVersion getLatestDatasetVersion(String name) {
        /*
          Combined Methods: getDatasetVersion, (assumed) listDatasetVersions
          Reason: Developers commonly want to retrieve the latest version of a dataset without manually enumerating all versions,
          sorting, and selecting the latest. This wrapper encapsulates that workflow, reducing boilerplate and potential errors.
        */
        // Pseudocode: Replace with actual listDatasetVersions API if available
        List<DatasetVersion> versions = listDatasetVersions(name); // Assumed existing method
        if (versions == null || versions.isEmpty()) {
            return null;
        }
        // Assume versions are sorted by version string or timestamp descending; otherwise, sort here.
        DatasetVersion latest = versions.get(0);
        return getDatasetVersion(name, latest.getVersion());
    }
    
    /**
     * Retrieves a DatasetVersion by name and version, returning null if not found instead of throwing.
     *
     * <p>This convenience method wraps getDatasetVersion and handles ResourceNotFoundException,
     * returning null when the dataset version does not exist. This pattern is common in Java and
     * reduces the need for repetitive try/catch blocks in client code.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @return The DatasetVersion if found, or null if it does not exist.
     */
    public DatasetVersion tryGetDatasetVersion(String name, String version) {
        /*
          Combined Methods: getDatasetVersion
          Reason: Developers often want to check for existence without handling exceptions for control flow.
          This wrapper provides a more idiomatic Java experience by returning null when not found.
        */
        try {
            return getDatasetVersion(name, version);
        } catch (ResourceNotFoundException ex) {
            return null;
        }
    }
    
    /**
     * Retrieves a DatasetVersion by name and version, with optional request options.
     *
     * <p>This overload provides a simplified way to call getDatasetVersionWithResponse without
     * requiring the caller to always construct a RequestOptions instance. If requestOptions is null,
     * sensible defaults are applied.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions Optional request options; may be null.
     * @return The DatasetVersion if found, or null if it does not exist.
     */
    public DatasetVersion getDatasetVersionOrNull(String name, String version, RequestOptions requestOptions) {
        /*
          Combined Methods: getDatasetVersionWithResponse
          Reason: Simplifies the pattern of calling getDatasetVersionWithResponse and handling not-found cases,
          while allowing optional request customization. This reduces boilerplate for common "get or null" scenarios.
        */
        try {
            RequestOptions opts = (requestOptions != null) ? requestOptions : new RequestOptions();
            Response<BinaryData> response = getDatasetVersionWithResponse(name, version, opts);
            return response.getValue().toObject(DatasetVersion.class);
        } catch (ResourceNotFoundException ex) {
            return null;
        }
    }/**
     * Creates or updates a dataset version from a file or folder path, automatically detecting the type.
     * <p>
     * If the provided path is a regular file, creates a FileDatasetVersion. If the path is a directory, creates a FolderDatasetVersion.
     * </p>
     * @param name The name of the dataset resource.
     * @param version The version id of the DatasetVersion to create or update.
     * @param path The file or folder path to upload.
     * @return The created or updated dataset version, as FileDatasetVersion or FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
     * @throws IOException If an I/O error occurs while accessing the file system.
     */
    public Object createDatasetFromPath(String name, String version, Path path) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder
          Reason: Developers often want to upload either a file or a folder as a dataset without worrying about which method to call. This wrapper detects the path type and delegates to the appropriate method, reducing boilerplate and improving clarity.
        */
        if (Files.isRegularFile(path)) {
            return createDatasetWithFile(name, version, path);
        } else if (Files.isDirectory(path)) {
            return createDatasetWithFolder(name, version, path);
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
        }
    }
    
    /**
     * Creates or updates a dataset version from a file, using sensible defaults for optional parameters.
     * <p>
     * This overload allows developers to quickly upload a file as a dataset version with minimal required parameters.
     * </p>
     * @param name The name of the dataset resource.
     * @param version The version id of the DatasetVersion to create or update.
     * @param filePath The path to the file to upload.
     * @return The created FileDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a file.
     */
    public FileDatasetVersion createDatasetFromFile(String name, String version, Path filePath) {
        /*
          Combined Methods: createDatasetWithFile
          Reason: Provides a more discoverable and idiomatic overload for uploading a file as a dataset, using a name that matches common developer intent and aligns with Azure SDK naming patterns.
        */
        return createDatasetWithFile(name, version, filePath);
    }
    
    /**
     * Creates or updates a dataset version from a folder, using sensible defaults for optional parameters.
     * <p>
     * This overload allows developers to quickly upload a folder as a dataset version with minimal required parameters.
     * </p>
     * @param name The name of the dataset resource.
     * @param version The version id of the DatasetVersion to create or update.
     * @param folderPath The path to the folder to upload.
     * @return The created FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException If an I/O error occurs while accessing the file system.
     */
    public FolderDatasetVersion createDatasetFromFolder(String name, String version, Path folderPath) throws IOException {
        /*
          Combined Methods: createDatasetWithFolder
          Reason: Provides a more discoverable and idiomatic overload for uploading a folder as a dataset, using a name that matches common developer intent and aligns with Azure SDK naming patterns.
        */
        return createDatasetWithFolder(name, version, folderPath);
    }
    
    /**
     * Creates or updates a dataset version from a file or folder path, with optional description and tags.
     * <p>
     * This method provides a high-level workflow for uploading a file or folder as a dataset version, allowing the caller to specify optional metadata.
     * </p>
     * @param name The name of the dataset resource.
     * @param version The version id of the DatasetVersion to create or update.
     * @param path The file or folder path to upload.
     * @param description Optional description for the dataset version.
     * @param tags Optional tags to associate with the dataset version.
     * @return The created or updated dataset version, as FileDatasetVersion or FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
     * @throws IOException If an I/O error occurs while accessing the file system.
     */
    public Object createDatasetFromPath(String name, String version, Path path, String description, Map<String, String> tags) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder, createOrUpdateDatasetVersionWithResponse
          Reason: Developers often want to upload a file or folder as a dataset and set optional metadata (description, tags) in a single call. This wrapper streamlines the workflow, reducing the need for manual construction of model objects and repetitive calls.
        */
        if (Files.isRegularFile(path)) {
            FileDatasetVersion datasetVersion = (FileDatasetVersion) createDatasetWithFile(name, version, path);
            if (description != null) {
                datasetVersion.setDescription(description);
            }
            if (tags != null) {
                datasetVersion.setTags(tags);
            }
            RequestOptions requestOptions = new RequestOptions();
            return createOrUpdateDatasetVersionWithResponse(
                name,
                version,
                BinaryData.fromObject(datasetVersion),
                requestOptions
            ).getValue().toObject(FileDatasetVersion.class);
        } else if (Files.isDirectory(path)) {
            FolderDatasetVersion datasetVersion = (FolderDatasetVersion) createDatasetWithFolder(name, version, path);
            if (description != null) {
                datasetVersion.setDescription(description);
            }
            if (tags != null) {
                datasetVersion.setTags(tags);
            }
            RequestOptions requestOptions = new RequestOptions();
            return createOrUpdateDatasetVersionWithResponse(
                name,
                version,
                BinaryData.fromObject(datasetVersion),
                requestOptions
            ).getValue().toObject(FolderDatasetVersion.class);
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
        }
    }/**
     * Starts or retrieves a pending upload for a dataset version with minimal required parameters.
     * <p>
     * This convenience method allows developers to initiate a pending upload by only specifying the dataset name, version, and required pending upload type.
     * Optional parameters such as connection name and pending upload ID are omitted for simplicity.
     * </p>
     */
    public PendingUploadResponse startPendingUpload(String name, String version, PendingUploadType pendingUploadType) {
        /*
          Combined Methods: pendingUpload
          Reason: Simplifies the most common workflow by allowing users to start a pending upload with only the required parameters,
          reducing boilerplate for the typical case where optional fields are not needed.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts or retrieves a pending upload for a dataset version with optional connection name.
     * <p>
     * This convenience method allows developers to specify a connection name in addition to the required parameters,
     * streamlining the process for scenarios where a connection is needed.
     * </p>
     */
    public PendingUploadResponse startPendingUpload(String name, String version, PendingUploadType pendingUploadType, String connectionName) {
        /*
          Combined Methods: pendingUpload
          Reason: Reduces friction for the common scenario where a connection name is specified, without requiring the user to construct the full request object.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setConnectionName(connectionName);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts or retrieves a pending upload for a dataset version with all possible parameters.
     * <p>
     * This convenience method allows developers to specify all parameters directly, including optional pending upload ID and connection name,
     * avoiding manual construction of the request object for advanced scenarios.
     * </p>
     */
    public PendingUploadResponse startPendingUpload(String name, String version, PendingUploadType pendingUploadType, String connectionName, String pendingUploadId) {
        /*
          Combined Methods: pendingUpload
          Reason: Provides a streamlined way to specify all parameters for advanced scenarios, improving clarity and reducing manual setup.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setConnectionName(connectionName)
            .setPendingUploadId(pendingUploadId);
        return pendingUpload(name, version, request);
    }/**
     * Deletes all versions of a Dataset, handling non-existent versions gracefully.
     *
     * This method retrieves all available versions for the given Dataset name and deletes each one.
     * If a version is already deleted or not found, it continues deleting the rest.
     */
    public void deleteAllDatasetVersions(String name) {
        /*
          Combined Methods: listDatasetVersions, deleteDatasetVersion
          Reason: Developers often want to delete all versions of a dataset as a single operation. This wrapper automates the repetitive workflow of enumerating all versions and deleting them individually, handling not-found errors gracefully to avoid interruption.
        */
        List<String> versions = listDatasetVersions(name); // Assumes this method exists and returns version strings
        for (String version : versions) {
            try {
                deleteDatasetVersion(name, version);
            } catch (ResourceNotFoundException ex) {
                // Ignore and continue; version already deleted
            }
        }
    }
    
    /**
     * Deletes a DatasetVersion if it exists, suppressing 'not found' errors.
     *
     * This method attempts to delete the specified DatasetVersion, but if it does not exist,
     * it will not throw an exception.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     */
    public void deleteDatasetVersionIfExists(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersion
          Reason: Developers may want to ensure a dataset version is deleted without having to handle 'not found' exceptions. This wrapper eliminates boilerplate try/catch for common idempotent delete scenarios.
        */
        try {
            deleteDatasetVersion(name, version);
        } catch (ResourceNotFoundException ex) {
            // Suppress exception if version does not exist
        }
    }
    
    /**
     * Deletes a DatasetVersion and returns true if the version was deleted, false if it did not exist.
     *
     * This method attempts to delete the specified DatasetVersion, returning a boolean to indicate
     * whether the deletion actually occurred.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @return true if the version was deleted, false if it did not exist.
     */
    public boolean deleteDatasetVersionIfPresent(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersion
          Reason: Provides a simple, intent-revealing API for idempotent deletes, allowing developers to check if a version was actually present and deleted, rather than handling exceptions.
        */
        try {
            deleteDatasetVersion(name, version);
            return true;
        } catch (ResourceNotFoundException ex) {
            return false;
        }
    }/**
     * Creates or updates a DatasetVersion with the specified name and version, using only the required parameters.
     * <p>
     * This convenience method streamlines the creation or update of a DatasetVersion by requiring only the most essential parameters:
     * <ul>
     *   <li>name (dataset name)</li>
     *   <li>version (dataset version)</li>
     *   <li>type (uri_file or uri_folder)</li>
     *   <li>dataUri (location of the data)</li>
     * </ul>
     * Optional parameters (description, tags, connectionName, isReference, etc.) are omitted for simplicity.
     * </p>
     * <p>
     * Use this method for the most common scenario where only the minimal information is needed to create or update a DatasetVersion.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version identifier.
     * @param type The type of the dataset version ("uri_file" or "uri_folder").
     * @param dataUri The URI to the data.
     * @return The created or updated DatasetVersion.
     */
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: This wrapper simplifies the creation/update workflow for the most common case by requiring only the minimal set of required parameters, reducing boilerplate and cognitive load for developers who do not need to specify optional fields.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with all commonly-used parameters, including optional description and tags.
     * <p>
     * This convenience method allows developers to specify the most frequently-used parameters for a DatasetVersion, including:
     * <ul>
     *   <li>name (dataset name)</li>
     *   <li>version (dataset version)</li>
     *   <li>type (uri_file or uri_folder)</li>
     *   <li>dataUri (location of the data)</li>
     *   <li>description (optional)</li>
     *   <li>tags (optional)</li>
     * </ul>
     * </p>
     * <p>
     * Use this method when you want to set a description or tags in addition to the required fields.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version identifier.
     * @param type The type of the dataset version ("uri_file" or "uri_folder").
     * @param dataUri The URI to the data.
     * @param description The description for the dataset version (optional).
     * @param tags The tags for the dataset version (optional).
     * @return The created or updated DatasetVersion.
     */
    public DatasetVersion createOrUpdateDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: This wrapper targets the common scenario where developers want to specify a description and tags, reducing the need to manually construct and populate a DatasetVersion model for these frequent use cases.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }/**
     * Obtains a SAS credential and blob URI for a dataset version, returning a strongly-typed result.
     * <p>
     * This method simplifies the process of retrieving the storage access credential and blob URI for a given dataset version,
     * handling request options, deserialization, and error propagation. It is intended for the common case where only the
     * resource name and version are needed, and the developer wants a typed result.
     * </p>
     */
    public AssetCredentialResult getDatasetVersionStorageCredential(String datasetName, String versionId) {
        /*
          Combined Methods: getCredentialsWithResponse, deserialization logic from getCredentials
          Reason: Developers commonly want to retrieve a SAS credential and blob URI for a dataset version as a strongly-typed object,
          without managing request options or manual deserialization. This wrapper streamlines the workflow, reduces boilerplate,
          and provides a clear, intent-driven API for the most common scenario.
        */
        RequestOptions requestOptions = new RequestOptions();
        Response<BinaryData> response = getCredentialsWithResponse(datasetName, versionId, requestOptions);
        return response.getValue().toObject(AssetCredentialResult.class);
    }
    
    /**
     * Obtains a SAS credential and blob URI for a dataset version, returning the strongly-typed result and full HTTP response.
     * <p>
     * This method is intended for advanced scenarios where the developer needs access to HTTP response metadata (such as status code or headers)
     * in addition to the deserialized credential result.
     * </p>
     */
    public Response<AssetCredentialResult> getDatasetVersionStorageCredentialWithResponse(String datasetName, String versionId, RequestOptions requestOptions) {
        /*
          Combined Methods: getCredentialsWithResponse, deserialization logic from getCredentials
          Reason: Developers may need both the strongly-typed credential result and HTTP response metadata (headers, status, etc.).
          This wrapper provides a clear, intent-driven API for this advanced scenario, reducing the need for manual deserialization.
        */
        Response<BinaryData> response = getCredentialsWithResponse(datasetName, versionId, requestOptions);
        AssetCredentialResult result = response.getValue().toObject(AssetCredentialResult.class);
        return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), result);
    }

    /********************* END OF GENERATED CODE *********************/

}
