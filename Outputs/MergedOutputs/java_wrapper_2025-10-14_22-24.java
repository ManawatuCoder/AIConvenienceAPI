// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Retrieves all versions of the specified dataset, or just the latest version if requested.
     * Simplifies the workflow of listing dataset versions by providing a single entry point for both common scenarios.
     *
     * @param name The name of the dataset resource.
     * @param latestOnly If true, returns only the latest version of each dataset; if false, returns all versions.
     * @return Paged collection of DatasetVersion items as a {@link PagedIterable}.
     */
    public PagedIterable<DatasetVersion> listDatasetVersions(String name, boolean latestOnly) {
        /*
          Combined Methods: listDatasetVersions, listLatestDatasetVersions
          Reason: Developers often want either all versions or just the latest version of a dataset. This wrapper provides a single, intent-driven entry point, reducing the need for developers to discover and choose between two similar methods. It streamlines the API surface and aligns with common developer workflows.
        */
        if (latestOnly) {
            return listLatestDatasetVersions();
        } else {
            return listDatasetVersions(name);
        }
    }/**
     * Retrieves a specific version of a DatasetVersion, providing sensible defaults for request options.
     * This overload streamlines the common scenario where only the resource name and version are required.
     */
    public DatasetVersion getDatasetVersion(String name, String version) {
        /*
          Combined Methods: getDatasetVersionWithResponse
          Reason: Provides a streamlined overload for the common case, hiding RequestOptions boilerplate and returning the logical entity directly, as per Azure SDK guidelines.
        */
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }
    
    /**
     * Retrieves a specific version of a DatasetVersion and returns the logical entity along with the full HTTP response.
     * This overload allows advanced users to specify custom request options.
     */
    public Response<DatasetVersion> getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        /*
          Combined Methods: getDatasetVersionWithResponse
          Reason: Improves developer experience by returning a strongly-typed logical entity (DatasetVersion) in the Response, eliminating the need for manual deserialization from BinaryData.
        */
        Response<BinaryData> response = getDatasetVersionWithResponse(name, version, requestOptions);
        DatasetVersion datasetVersion = response.getValue().toObject(DatasetVersion.class);
        return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), datasetVersion);
    }/**
     * Creates or updates a dataset version from a file or folder, automatically detecting the type and handling upload.
     *
     * <p>
     * This method simplifies dataset creation by handling both file and folder sources, managing pending upload requests,
     * uploading content, and registering the dataset version. It eliminates the need for the developer to manually check
     * file/folder types, perform multi-step upload logic, or construct request payloads.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param path The path to the file or folder to upload.
     * @return The created dataset version as either FileDatasetVersion or FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
     * @throws IOException If an I/O error occurs when accessing the file system.
     */
    public Object createOrUpdateDatasetVersion(String name, String version, Path path) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder, pendingUpload, createOrUpdateDatasetVersionWithResponse
          Reason: This wrapper abstracts the repetitive and error-prone logic of distinguishing between file and folder uploads,
          managing pending upload requests, uploading content, and registering the dataset version. It enables a single, intent-driven
          method for the common workflow of dataset version creation from local sources, reducing boilerplate and potential for error.
        */
        if (Files.isRegularFile(path)) {
            // File upload workflow
            PendingUploadRequest body = new PendingUploadRequest();
            PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
            SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
            String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
            BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
            blobClient.upload(BinaryData.fromFile(path));
            RequestOptions requestOptions = new RequestOptions();
            FileDatasetVersion datasetVersion = this
                .createOrUpdateDatasetVersionWithResponse(name, version,
                    BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
                .getValue()
                .toObject(FileDatasetVersion.class);
            return datasetVersion;
        } else if (Files.isDirectory(path)) {
            // Folder upload workflow
            PendingUploadRequest request = new PendingUploadRequest();
            PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
            String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
            SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
            String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
            Files.walk(path).filter(Files::isRegularFile).forEach(filePath -> {
                String relativePath = path.relativize(filePath).toString().replace('\\', '/');
                BlobClient blobClient
                    = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
                blobClient.upload(BinaryData.fromFile(filePath), true);
            });
            RequestOptions requestOptions = new RequestOptions();
            FolderDatasetVersion datasetVersion = this
                .createOrUpdateDatasetVersionWithResponse(name, version,
                    BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
                .getValue()
                .toObject(FolderDatasetVersion.class);
            return datasetVersion;
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a folder: " + path);
        }
    }
    
    /**
     * Creates or updates a dataset version from a file, with sensible defaults for common scenarios.
     *
     * <p>
     * This method streamlines the process of uploading a file as a dataset version by handling pending upload requests,
     * blob upload, and dataset registration with minimal required parameters.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param filePath The path to the file to upload.
     * @return The created FileDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a file.
     */
    public FileDatasetVersion createDatasetVersionFromFile(String name, String version, Path filePath) {
        /*
          Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
          Reason: This wrapper eliminates repetitive setup for file-based dataset version creation, providing a clear,
          intent-driven method for the most common file upload scenario.
        */
        if (!Files.isRegularFile(filePath)) {
            throw new IllegalArgumentException("The provided path is not a file: " + filePath);
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }
    
    /**
     * Creates or updates a dataset version from a folder, with sensible defaults for common scenarios.
     *
     * <p>
     * This method streamlines the process of uploading a folder as a dataset version by handling pending upload requests,
     * recursive file upload, and dataset registration with minimal required parameters.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param folderPath The path to the folder to upload.
     * @return The created FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException If an I/O error occurs when accessing the file system.
     */
    public FolderDatasetVersion createDatasetVersionFromFolder(String name, String version, Path folderPath) throws IOException {
        /*
          Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
          Reason: This wrapper eliminates repetitive setup for folder-based dataset version creation, providing a clear,
          intent-driven method for the most common folder upload scenario.
        */
        if (!Files.isDirectory(folderPath)) {
            throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
        }
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }/**
     * Starts a new pending upload or retrieves an existing one for a dataset version, using only required parameters and sensible defaults.
     * <p>
     * This method simplifies the process of initiating a pending upload for the most common scenario,
     * requiring only the dataset name, version, and the required pending upload type.
     * Optional parameters such as pendingUploadId and connectionName are omitted for simplicity.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType) {
        /*
          Combined Methods: pendingUpload
          Reason: Provides a streamlined overload for the most common workflow, reducing boilerplate by
          allowing the developer to specify only the required fields. This eliminates the need to manually
          construct a PendingUploadRequest for the simple case, improving clarity and reducing friction.
        */
        PendingUploadRequest request = new PendingUploadRequest();
        request.setPendingUploadType(pendingUploadType);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts a new pending upload or retrieves an existing one for a dataset version, allowing the caller to specify a connection name.
     * <p>
     * This method simplifies the process of initiating a pending upload for scenarios where a connection name is commonly used,
     * requiring only the dataset name, version, pending upload type, and connection name.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param connectionName The name of the connection to use for the upload.
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
        /*
          Combined Methods: pendingUpload
          Reason: Reduces boilerplate for a common scenario where a connection name is specified, letting developers avoid manual construction of the request object.
        */
        PendingUploadRequest request = new PendingUploadRequest();
        request.setPendingUploadType(pendingUploadType);
        request.setConnectionName(connectionName);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts or retrieves a pending upload for a dataset version, specifying all commonly-used parameters.
     * <p>
     * This method provides a streamlined overload for the scenario where a pending upload ID is reused (e.g., for resuming uploads),
     * in addition to specifying the connection name and upload type.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param connectionName The name of the connection to use for the upload.
     * @param pendingUploadId The ID of an existing pending upload to resume, or null to start a new one.
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startOrResumePendingUpload(String name, String version, String pendingUploadType, String connectionName, String pendingUploadId) {
        /*
          Combined Methods: pendingUpload
          Reason: Provides a clear, intent-driven method for resuming or starting uploads, reducing manual request object setup and clarifying the workflow for resuming uploads.
        */
        PendingUploadRequest request = new PendingUploadRequest();
        request.setPendingUploadType(pendingUploadType);
        request.setConnectionName(connectionName);
        request.setPendingUploadId(pendingUploadId);
        return pendingUpload(name, version, request);
    }/**
     * Creates or updates a DatasetVersion with the given name and version, using only the required parameters.
     * <p>
     * This overload provides a streamlined way to upsert a DatasetVersion when only the required fields are needed.
     * Optional fields (description, tags, etc.) can be set on the DatasetVersion model before passing it in.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: Developers commonly want to quickly create or update a DatasetVersion with minimal required information.
          This wrapper reduces boilerplate by constructing the DatasetVersion model with required fields, allowing
          for a fast-path upsert scenario. Optional fields can be set by the developer on the returned object if needed.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with the given name and version, including optional description and tags.
     * <p>
     * This overload simplifies the common scenario where a developer wants to upsert a DatasetVersion and also
     * provide a description and tags, without manually constructing the DatasetVersion model.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: Developers often want to specify description and tags when creating or updating a DatasetVersion.
          This wrapper reduces repetitive model construction and parameter mapping, improving clarity and usability.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with all available options, using a builder-style options parameter.
     * <p>
     * This overload enables future extensibility and aligns with the Azure SDK options pattern, allowing
     * developers to fluently specify only the fields they care about.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(UpsertDatasetVersionOptions options) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: This wrapper introduces an options parameter pattern for extensibility and fluent usage, reducing
          the need for multiple overloads as the DatasetVersion model evolves. It aligns with Azure SDK guidelines
          for complex inputs and future-proofs the API surface.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(options.getName())
            .setVersion(options.getVersion())
            .setType(options.getType())
            .setDataUri(options.getDataUri())
            .setIsReference(options.isReference())
            .setConnectionName(options.getConnectionName())
            .setDescription(options.getDescription())
            .setTags(options.getTags());
        return createOrUpdateDatasetVersion(options.getName(), options.getVersion(), datasetVersion);
    }/**
     * Deletes all versions of a dataset with the given name.
     * <p>
     * This method finds and deletes all versions of the specified dataset, handling common error scenarios.
     * </p>
     *
     * @param name The name of the dataset whose versions are to be deleted.
     * @throws IllegalArgumentException if the name is null or empty.
     * @throws RuntimeException if any delete operation fails.
     */
    public void deleteAllDatasetVersions(String name) {
        /*
          Combined Methods: listDatasetVersions, deleteDatasetVersion
          Reason: Developers often want to clean up all versions of a dataset. This wrapper automates the repetitive pattern of listing all versions and deleting them one by one, handling errors and reducing boilerplate.
        */
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Dataset name cannot be null or empty.");
        }
        // Assume listDatasetVersions returns a List<DatasetVersion> or similar
        List<DatasetVersion> versions = listDatasetVersions(name);
        for (DatasetVersion version : versions) {
            try {
                deleteDatasetVersion(name, version.getVersion());
            } catch (ResourceNotFoundException ex) {
                // Already deleted, skip
            } catch (Exception ex) {
                throw new RuntimeException("Failed to delete dataset version: " + version.getVersion(), ex);
            }
        }
    }
    
    /**
     * Deletes the latest version of a dataset.
     * <p>
     * This method finds the most recent version of the specified dataset and deletes it.
     * </p>
     *
     * @param name The name of the dataset.
     * @throws IllegalArgumentException if the name is null or empty.
     * @throws ResourceNotFoundException if no versions exist.
     * @throws RuntimeException if the delete operation fails.
     */
    public void deleteLatestDatasetVersion(String name) {
        /*
          Combined Methods: listDatasetVersions, deleteDatasetVersion
          Reason: Deleting the latest version is a common workflow. This wrapper encapsulates the logic to find the latest version and delete it, reducing error-prone manual steps.
        */
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Dataset name cannot be null or empty.");
        }
        List<DatasetVersion> versions = listDatasetVersions(name);
        if (versions.isEmpty()) {
            throw new ResourceNotFoundException("No versions found for dataset: " + name);
        }
        // Assume versions are sorted by version string or timestamp descending
        DatasetVersion latest = versions.get(0);
        deleteDatasetVersion(name, latest.getVersion());
    }
    
    /**
     * Deletes a dataset version if it exists, suppressing ResourceNotFoundException.
     * <p>
     * This method attempts to delete a dataset version, but does not throw if the version does not exist.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version to delete.
     * @throws IllegalArgumentException if parameters are invalid.
     * @throws RuntimeException if the delete operation fails for reasons other than not found.
     */
    public void deleteDatasetVersionIfExists(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersion
          Reason: Developers often want idempotent deletes. This wrapper suppresses errors if the version does not exist, aligning with common "delete if exists" semantics.
        */
        try {
            deleteDatasetVersion(name, version);
        } catch (ResourceNotFoundException ex) {
            // Ignore, as the intent is to ensure deletion
        }
    }/**
     * Retrieves the SAS credential URI for the storage account associated with a specific Dataset version.
     * <p>
     * This method simplifies access to the SAS URI by extracting it directly from the credential response,
     * allowing developers to quickly obtain the URI needed for storage operations without manually parsing
     * the full credential result.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The version identifier of the Dataset.
     * @return The SAS URI string for accessing the storage account blob.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by the server.
     * @throws ClientAuthenticationException if authentication fails.
     * @throws ResourceNotFoundException if the resource is not found.
     * @throws ResourceModifiedException if the resource is in a conflict state.
     * @throws RuntimeException for other request failures.
     */
    public String getDatasetVersionSasUri(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Developers commonly need just the SAS URI to access storage, not the full credential object.
          This wrapper eliminates the need for manual parsing of the AssetCredentialResult, streamlining the
          workflow for storage access and reducing boilerplate.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null
            || result.getBlobReference().getCredential() == null
            || result.getBlobReference().getCredential().getSasUri() == null) {
            throw new IllegalStateException("SAS URI could not be retrieved from the credential result.");
        }
        return result.getBlobReference().getCredential().getSasUri();
    }
    
    /**
     * Retrieves the storage account blob URI and its associated SAS credential for a specific Dataset version.
     * <p>
     * This method provides both the blob URI and the SAS token together, which are typically required together
     * for performing authenticated storage operations. It reduces the need for manual extraction from the
     * credential result and provides a clear, intent-driven API for storage access.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The version identifier of the Dataset.
     * @return A simple pair containing the blob URI and the SAS URI.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by the server.
     * @throws ClientAuthenticationException if authentication fails.
     * @throws ResourceNotFoundException if the resource is not found.
     * @throws ResourceModifiedException if the resource is in a conflict state.
     * @throws RuntimeException for other request failures.
     */
    public java.util.AbstractMap.SimpleEntry<String, String> getDatasetVersionBlobAndSasUri(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Accessing a storage blob typically requires both the blob URI and its SAS credential.
          This wrapper provides both in a single call, reducing repetitive extraction logic and clarifying
          developer intent for common storage access scenarios.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null
            || result.getBlobReference().getCredential() == null
            || result.getBlobReference().getBlobUri() == null
            || result.getBlobReference().getCredential().getSasUri() == null) {
            throw new IllegalStateException("Blob URI or SAS URI could not be retrieved from the credential result.");
        }
        return new java.util.AbstractMap.SimpleEntry<>(
            result.getBlobReference().getBlobUri(),
            result.getBlobReference().getCredential().getSasUri()
        );
    }

    /********************* END OF GENERATED CODE *********************/

}
