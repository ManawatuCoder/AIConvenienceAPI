// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Retrieves all versions of a dataset, sorted with the latest version first.
     *
     * <p>This method combines listing all dataset versions and sorting them so that the latest version appears first.
     * This is a common developer workflow when browsing or displaying dataset histories, and avoids the need for manual sorting.</p>
     */
    public List<DatasetVersion> listAllDatasetVersionsLatestFirst(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Developers often want to view dataset version history with the latest version first. This wrapper retrieves all versions and sorts them by version descending, eliminating manual sorting boilerplate.
        */
        List<DatasetVersion> versions = new ArrayList<>();
        for (DatasetVersion version : listDatasetVersions(name)) {
            versions.add(version);
        }
        versions.sort(Comparator.comparing(DatasetVersion::getVersion).reversed());
        return versions;
    }
    
    /**
     * Retrieves the latest version of a dataset by name.
     *
     * <p>This method combines listing all versions and selecting the latest one, which is a common developer need.
     * It avoids the need for users to manually iterate and compare versions.</p>
     */
    public Optional<DatasetVersion> getLatestDatasetVersion(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Developers frequently need just the latest version of a dataset. This wrapper fetches all versions and returns the one with the highest version, reducing boilerplate and potential errors.
        */
        return StreamSupport.stream(listDatasetVersions(name).spliterator(), false)
            .max(Comparator.comparing(DatasetVersion::getVersion));
    }
    
    /**
     * Retrieves all latest versions of all datasets.
     *
     * <p>This method wraps the listing of latest dataset versions and collects them into a list for easier consumption.</p>
     */
    public List<DatasetVersion> listAllLatestDatasetVersions() {
        /*
          Combined Methods: listLatestDatasetVersions
          Reason: Developers often want a concrete list of the latest version for each dataset, rather than a paged iterable. This wrapper collects all items, simplifying iteration and further processing.
        */
        List<DatasetVersion> latestVersions = new ArrayList<>();
        for (DatasetVersion version : listLatestDatasetVersions()) {
            latestVersions.add(version);
        }
        return latestVersions;
    }/**
     * Begins a new pending upload for a dataset version, or retrieves an existing one, using only the required parameters.
     * <p>
     * This convenience method streamlines the common scenario where only the dataset name, version, and pending upload type are needed,
     * providing sensible defaults for optional fields and reducing boilerplate.
     * </p>
     * 
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @return The pending upload response containing upload details.
     */
    public PendingUploadResponse beginPendingUpload(String name, String version, String pendingUploadType) {
        /*
          Combined Methods: pendingUpload
          Reason: Developers typically want to initiate a pending upload with minimal required information. This wrapper reduces the need to manually construct a PendingUploadRequest for the most common case, eliminating repetitive setup and parameter boilerplate.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Begins a new pending upload for a dataset version, or retrieves an existing one, allowing optional connection name.
     * <p>
     * This convenience method streamlines the scenario where a developer may wish to specify a connection name, but does not need to set other optional fields.
     * </p>
     * 
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param connectionName The name of the storage connection to use (optional).
     * @return The pending upload response containing upload details.
     */
    public PendingUploadResponse beginPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
        /*
          Combined Methods: pendingUpload
          Reason: Developers often need to specify a connection name in addition to required fields. This wrapper eliminates the need to manually construct a PendingUploadRequest for this common scenario, improving clarity and reducing boilerplate.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setConnectionName(connectionName);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Begins or retrieves a pending upload for a dataset version, using only the required parameters, and returns the full HTTP response.
     * <p>
     * This overload provides access to HTTP response metadata for advanced scenarios, while still simplifying request construction for the common case.
     * </p>
     * 
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param requestOptions The options to configure the HTTP request.
     * @return The HTTP response containing the pending upload details as a strongly-typed object.
     */
    public Response<PendingUploadResponse> beginPendingUploadWithResponse(String name, String version, String pendingUploadType, RequestOptions requestOptions) {
        /*
          Combined Methods: pendingUploadWithResponse
          Reason: This wrapper reduces boilerplate for developers who need HTTP response metadata, but want to provide only the minimal required information for the upload request.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType);
        Response<BinaryData> response = pendingUploadWithResponse(name, version, BinaryData.fromObject(request), requestOptions);
        return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), response.getValue().toObject(PendingUploadResponse.class));
    }/**
     * Retrieves the specific version of a DatasetVersion with sensible defaults and simplified usage.
     * <p>
     * This method streamlines the retrieval of a DatasetVersion by hiding the need for explicit RequestOptions construction,
     * and provides a single, clear entry point for the most common scenario: fetching a DatasetVersion by name and version.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @return The specific version of the DatasetVersion.
     */
    public DatasetVersion fetchDatasetVersion(String name, String version) {
        /*
          Combined Methods: getDatasetVersionWithResponse
          Reason: Eliminates the need for the user to manually construct RequestOptions for the common case,
          providing a more direct and idiomatic way to retrieve a DatasetVersion by name and version.
          This wrapper aligns with Azure SDK guidelines by offering a streamlined overload for the most typical workflow.
        */
        return getDatasetVersionWithResponse(name, version, new RequestOptions())
            .getValue()
            .toObject(DatasetVersion.class);
    }
    
    /**
     * Retrieves the specific version of a DatasetVersion, returning the full HTTP response for advanced scenarios.
     * <p>
     * This method provides a simplified overload for advanced users who want access to the full HTTP response,
     * but do not need to manually construct RequestOptions for the common case.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @return The full HTTP response containing the DatasetVersion as BinaryData.
     */
    public Response<BinaryData> fetchDatasetVersionWithResponse(String name, String version) {
        /*
          Combined Methods: getDatasetVersionWithResponse
          Reason: Removes repetitive boilerplate by supplying a default RequestOptions instance, 
          allowing users to access the full HTTP response without unnecessary setup for the common scenario.
          This improves clarity and reduces friction for advanced users.
        */
        return getDatasetVersionWithResponse(name, version, new RequestOptions());
    }/**
     * Creates or updates a dataset version from a file or folder path, automatically detecting the type and handling upload.
     *
     * <p>
     * This method streamlines the process of creating or updating a dataset version by:
     * <ul>
     *   <li>Automatically determining whether the provided path is a file or a folder.</li>
     *   <li>Handling the upload process for both files and folders, including all necessary setup and validation.</li>
     *   <li>Reducing the need for the user to manually choose between file and folder upload APIs.</li>
     * </ul>
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param path The path to the file or folder containing data to upload.
     * @return The created dataset version, either FileDatasetVersion or FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
     * @throws IOException If an I/O error is thrown when accessing the file system.
     */
    public Object upsertDatasetVersionFromPath(String name, String version, Path path) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder
          Reason: Developers often want to create or update a dataset version from a local path without worrying about
          whether it's a file or folder. This wrapper automates detection and dispatch, reducing boilerplate and
          eliminating the need for manual branching and error-prone setup.
        */
        if (Files.isRegularFile(path)) {
            return createDatasetWithFile(name, version, path);
        } else if (Files.isDirectory(path)) {
            return createDatasetWithFolder(name, version, path);
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
        }
    }
    
    /**
     * Creates or updates a dataset version from a file, with minimal parameters and sensible defaults.
     *
     * <p>
     * This method simplifies the process of uploading a file as a dataset version by:
     * <ul>
     *   <li>Validating the file path and handling all upload steps internally.</li>
     *   <li>Using default options for upload and dataset creation.</li>
     *   <li>Reducing the required parameters to only those essential for the operation.</li>
     * </ul>
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the file to upload.
     * @return The created FileDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a file.
     */
    public FileDatasetVersion upsertDatasetVersionFromFile(String name, String version, Path filePath) {
        /*
          Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
          Reason: Developers frequently want to upload a single file as a dataset version without managing upload requests,
          credentials, or constructing intermediate objects. This wrapper hides those details and provides a streamlined,
          intent-driven API.
        */
        return createDatasetWithFile(name, version, filePath);
    }
    
    /**
     * Creates or updates a dataset version from a folder, with minimal parameters and sensible defaults.
     *
     * <p>
     * This method simplifies the process of uploading a folder as a dataset version by:
     * <ul>
     *   <li>Validating the folder path and handling recursive upload of all files.</li>
     *   <li>Using default options for upload and dataset creation.</li>
     *   <li>Reducing the required parameters to only those essential for the operation.</li>
     * </ul>
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder to upload.
     * @return The created FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException If an I/O error is thrown when accessing the file system.
     */
    public FolderDatasetVersion upsertDatasetVersionFromFolder(String name, String version, Path folderPath) throws IOException {
        /*
          Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
          Reason: Developers frequently want to upload a folder as a dataset version without managing upload requests,
          credentials, or constructing intermediate objects. This wrapper hides those details and provides a streamlined,
          intent-driven API.
        */
        return createDatasetWithFolder(name, version, folderPath);
    }
    
    /**
     * Creates or updates a dataset version from a data URI, with optional metadata.
     *
     * <p>
     * This method allows developers to create or update a dataset version by providing a data URI directly,
     * optionally specifying description and tags, and using sensible defaults for other parameters.
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param dataUri The URI pointing to the data (file or folder).
     * @param type The type of dataset ("uri_file" or "uri_folder").
     * @param description Optional description for the dataset version.
     * @param tags Optional tags for the dataset version.
     * @return The created or updated dataset version as a logical entity.
     */
    public Object upsertDatasetVersionFromUri(String name, String version, String dataUri, String type, String description, Map<String, String> tags) {
        /*
          Combined Methods: createOrUpdateDatasetVersionWithResponse
          Reason: Developers may want to register a dataset version from an existing URI, optionally adding metadata,
          without constructing a full DatasetVersion object or handling request options. This wrapper provides a concise,
          intent-driven API for this common scenario.
        */
        RequestOptions requestOptions = new RequestOptions();
        Object datasetVersion;
        if ("uri_file".equals(type)) {
            FileDatasetVersion fileVersion = new FileDatasetVersion()
                .setDataUri(dataUri)
                .setName(name)
                .setVersion(version)
                .setDescription(description)
                .setTags(tags);
            datasetVersion = this.createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(fileVersion), requestOptions)
                .getValue()
                .toObject(FileDatasetVersion.class);
        } else if ("uri_folder".equals(type)) {
            FolderDatasetVersion folderVersion = new FolderDatasetVersion()
                .setDataUri(dataUri)
                .setName(name)
                .setVersion(version)
                .setDescription(description)
                .setTags(tags);
            datasetVersion = this.createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(folderVersion), requestOptions)
                .getValue()
                .toObject(FolderDatasetVersion.class);
        } else {
            throw new IllegalArgumentException("Unsupported dataset type: " + type);
        }
        return datasetVersion;
    }/**
     * Deletes all versions of the specified Dataset.
     *
     * This method deletes all versions of a Dataset by enumerating all available versions and deleting each one.
     * It is useful for scenarios where a developer wants to ensure a Dataset is fully removed, regardless of how many versions exist.
     */
    public void deleteAllDatasetVersions(String name) {
        /*
          Combined Methods: listDatasetVersions, deleteDatasetVersion
          Reason: Developers often want to delete an entire Dataset, not just a single version. This wrapper automates the repetitive workflow of enumerating all versions and deleting them one by one, reducing boilerplate and the risk of missing versions.
        */
        List<String> versions = listDatasetVersions(name); // Assume this method exists and returns all version strings for the dataset
        for (String version : versions) {
            deleteDatasetVersion(name, version);
        }
    }
    
    /**
     * Deletes the latest version of the specified Dataset.
     *
     * This method finds and deletes the most recent version of a Dataset, simplifying the common task of cleaning up only the latest version.
     */
    public void deleteLatestDatasetVersion(String name) {
        /*
          Combined Methods: listDatasetVersions, deleteDatasetVersion
          Reason: Developers may often want to delete just the latest version of a Dataset. This wrapper hides the logic of identifying the latest version and performing the delete, streamlining a common workflow.
        */
        List<String> versions = listDatasetVersions(name); // Assume this method exists and returns all version strings for the dataset
        if (!versions.isEmpty()) {
            String latestVersion = Collections.max(versions); // Assumes version strings are comparable
            deleteDatasetVersion(name, latestVersion);
        }
    }
    
    /**
     * Deletes the specified version of a Dataset, suppressing ResourceNotFoundException if the version does not exist.
     *
     * This method is useful for idempotent delete scenarios where the developer does not care if the version is already deleted.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     */
    public void deleteDatasetVersionIfExists(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersion
          Reason: Deleting resources idempotently is a common pattern. This wrapper suppresses errors when the resource is already deleted, reducing error handling boilerplate for the user.
        */
        try {
            deleteDatasetVersion(name, version);
        } catch (ResourceNotFoundException ex) {
            // Suppress, as the resource is already gone
        }
    }/**
     * Creates or updates a DatasetVersion with the given required fields, providing a streamlined overload for the most common scenario.
     * <p>
     * This convenience method allows developers to create or update a DatasetVersion by specifying only the required parameters:
     * name, version, type, and dataUri. Optional fields such as description, tags, isReference, and connectionName are omitted for simplicity.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: Developers frequently want to create or update a dataset version with only the required fields.
          This wrapper eliminates the need to manually construct a DatasetVersion object and set required properties,
          reducing boilerplate and potential errors. It aligns with the options pattern by providing a simple overload for the common case.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with all common fields, including optional description and tags.
     * <p>
     * This overload simplifies the creation or update of a DatasetVersion by allowing the caller to specify
     * the most commonly used fields directly, without manually constructing and populating a DatasetVersion object.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: Developers often want to create or update a dataset version with both required and commonly-used optional fields.
          This wrapper reduces repetitive setup and improves clarity by exposing the most relevant parameters directly,
          while still allowing the full power of the underlying method for advanced scenarios.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }/**
     * Retrieves the SAS URI for accessing the storage blob associated with a specific Dataset version.
     * <p>
     * This method abstracts away the details of extracting the SAS URI from the credential response,
     * providing direct access to the blob's SAS URI for common scenarios such as downloading or uploading data.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return The SAS URI string for the storage blob associated with the Dataset version.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by server.
     * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException if the request is rejected by server on status code 409.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public String getDatasetVersionBlobSasUri(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Developers frequently need the SAS URI to access the dataset blob directly. This wrapper eliminates the need to manually navigate the AssetCredentialResult structure, streamlining a common workflow and reducing boilerplate code.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null ||
            result.getBlobReference().getCredential() == null ||
            result.getBlobReference().getCredential().getSasUri() == null) {
            throw new IllegalStateException("SAS URI not found in credential response.");
        }
        return result.getBlobReference().getCredential().getSasUri();
    }
    
    
    /**
     * Retrieves the storage blob URI and its associated SAS credential for a specific Dataset version as a simple pair.
     * <p>
     * This method provides both the blob URI and the SAS URI together, making it easier for developers to access or reference both endpoints without parsing nested result objects.
     * </p>
     *
     * @param name The name of the Dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return A simple two-element array: [0] = blobUri, [1] = sasUri.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by server.
     * @throws ClientAuthenticationException if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException if the request is rejected by server on status code 409.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public String[] getDatasetVersionBlobUris(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Developers often need both the blob URI and its SAS credential together for storage operations. This wrapper provides a concise, direct way to obtain both values, avoiding repetitive extraction logic and improving clarity for common integration scenarios.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null ||
            result.getBlobReference().getCredential() == null ||
            result.getBlobReference().getCredential().getSasUri() == null ||
            result.getBlobReference().getBlobUri() == null) {
            throw new IllegalStateException("Blob URI or SAS URI not found in credential response.");
        }
        return new String[] {
            result.getBlobReference().getBlobUri(),
            result.getBlobReference().getCredential().getSasUri()
        };
    }

    /********************* END OF GENERATED CODE *********************/

}
