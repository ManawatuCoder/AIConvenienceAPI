// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Creates or updates a DatasetVersion and immediately retrieves the resulting DatasetVersion.
     * <p>
     * This method streamlines the common workflow of upserting a DatasetVersion and then fetching its server-generated state,
     * such as IDs, tags, or computed fields. It ensures the returned object reflects the persisted state as stored by the service.
     * </p>
     */
    public DatasetVersion upsertAndFetchDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        /*
          Combined Methods: createOrUpdateDatasetVersion, getDatasetVersion
          Reason: Developers often want to confirm the persisted state of a DatasetVersion after upsert, including any default values or server-side modifications. This wrapper eliminates the need for two manual calls and ensures the returned object matches the service-side resource.
        */
        createOrUpdateDatasetVersion(name, version, datasetVersion);
        return getDatasetVersion(name, version);
    }
    
    /**
     * Deletes a DatasetVersion if it exists, and returns whether the deletion was successful.
     * <p>
     * This method simplifies the common workflow of attempting to delete a DatasetVersion, returning a boolean to indicate
     * whether the resource was actually deleted (true) or did not exist (false). It handles 404 (not found) gracefully.
     * </p>
     */
    public boolean deleteDatasetVersionIfExists(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersionWithResponse
          Reason: Deleting a resource often requires checking for existence and handling not-found errors. This wrapper provides a simple boolean result, reducing error handling boilerplate for the common "delete if exists" scenario.
        */
        try {
            deleteDatasetVersionWithResponse(name, version, new RequestOptions());
            return true;
        } catch (ResourceNotFoundException ex) {
            return false;
        }
    }
    
    /**
     * Creates a new DatasetVersion with minimal required information.
     * <p>
     * This method provides a streamlined way to create a DatasetVersion when only the required fields are known.
     * Optional fields are omitted, and sensible defaults are applied.
     * </p>
     */
    public DatasetVersion createDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion
          Reason: Creating a DatasetVersion often only requires a few required fields. This wrapper reduces boilerplate by constructing the DatasetVersion model with only the essentials, enabling a quick-start experience for common scenarios.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }/**
     * Retrieves all versions of a dataset, with an option to only return the latest version for each dataset.
     * <p>
     * This method simplifies the common workflow of listing dataset versions, allowing developers to specify whether they want all versions or just the latest ones, without needing to call separate methods.
     * </p>
     *
     * @param name The name of the dataset. If null, retrieves the latest version for all datasets.
     * @param latestOnly If true, returns only the latest version for each dataset; if false, returns all versions for the specified dataset.
     * @return A paged collection of {@link DatasetVersion} items.
     */
    public PagedIterable<DatasetVersion> listDatasetVersions(String name, boolean latestOnly) {
        /*
          Combined Methods: listDatasetVersions, listLatestDatasetVersions
          Reason: Developers often want to either list all versions for a dataset or just the latest versions across datasets.
          This wrapper unifies both workflows, reducing the need for conditional logic and method selection in user code.
        */
        if (latestOnly) {
            // If name is provided, filter results to that dataset after fetching all latest versions
            if (name != null) {
                return serviceClient.listLatestDatasetVersions(new RequestOptions())
                    .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class))
                    .stream()
                    .filter(v -> name.equals(v.getName()))
                    .collect(PagedIterable.toPagedIterable());
            } else {
                return serviceClient.listLatestDatasetVersions(new RequestOptions())
                    .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
            }
        } else {
            if (name == null) {
                throw new IllegalArgumentException("Dataset name must be provided when latestOnly is false.");
            }
            return serviceClient.listDatasetVersions(name, new RequestOptions())
                .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
        }
    }
    
    /**
     * Retrieves all versions of the specified dataset.
     * <p>
     * This method provides a streamlined way to list all versions for a dataset, using a sensible default for request options.
     * </p>
     *
     * @param name The name of the dataset.
     * @return A paged collection of {@link DatasetVersion} items.
     */
    public PagedIterable<DatasetVersion> listAllDatasetVersions(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Provides a clear, intent-revealing method name for the common scenario of listing all versions for a dataset, reducing ambiguity and boilerplate.
        */
        return serviceClient.listDatasetVersions(name, new RequestOptions())
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }
    
    /**
     * Retrieves the latest version of each dataset.
     * <p>
     * This method provides a clear, intent-revealing method name for the common scenario of listing only the latest versions, reducing ambiguity and boilerplate.
     * </p>
     *
     * @return A paged collection of {@link DatasetVersion} items.
     */
    public PagedIterable<DatasetVersion> listAllLatestDatasetVersions() {
        /*
          Combined Methods: listLatestDatasetVersions
          Reason: Provides a clear, intent-revealing method name for the common scenario of listing only the latest versions, reducing ambiguity and boilerplate.
        */
        return serviceClient.listLatestDatasetVersions(new RequestOptions())
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }/**
     * Initiates a new pending upload or retrieves an existing one for a dataset version, using only required parameters and sensible defaults for common scenarios.
     * <p>
     * This method streamlines the process of starting or retrieving a pending upload by requiring only the dataset name, version, and upload type. Optional parameters are omitted for simplicity.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version of the dataset.
     * @param pendingUploadType The type of pending upload ("None" or "BlobReference").
     * @return The response containing pending upload details.
     */
    public PendingUploadResponse startOrGetPendingUpload(String name, String version, String pendingUploadType) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: Simplifies the most common workflow by requiring only the essential parameters (name, version, type), 
          and internally constructs the PendingUploadRequest. This eliminates boilerplate and reduces user error in constructing the request object for standard cases.
        */
        PendingUploadRequest request = new PendingUploadRequest().setPendingUploadType(pendingUploadType);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Initiates a new pending upload or retrieves an existing one for a dataset version, allowing the caller to specify a connection name.
     * <p>
     * This method streamlines the process of starting or retrieving a pending upload by requiring only the dataset name, version, upload type, and connection name.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version of the dataset.
     * @param pendingUploadType The type of pending upload ("None" or "BlobReference").
     * @param connectionName The name of the connection to use.
     * @return The response containing pending upload details.
     */
    public PendingUploadResponse startOrGetPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: Further streamlines the workflow for scenarios where a connection name is commonly specified, 
          reducing manual construction of the PendingUploadRequest and improving clarity.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setConnectionName(connectionName);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Initiates or retrieves a pending upload for a dataset version, returning the HTTP response for advanced scenarios.
     * <p>
     * This method provides a simplified overload for the maximal pendingUploadWithResponse method, 
     * constructing the request body from the essential parameters and applying default request options.
     * </p>
     *
     * @param name The name of the dataset.
     * @param version The version of the dataset.
     * @param pendingUploadType The type of pending upload ("None" or "BlobReference").
     * @return The HTTP response containing pending upload details as a strongly-typed object.
     */
    public Response<PendingUploadResponse> startOrGetPendingUploadWithResponse(String name, String version, String pendingUploadType) {
        /*
          Combined Methods: pendingUploadWithResponse(String, String, BinaryData, RequestOptions)
          Reason: Reduces friction for users who require the full HTTP response, by handling the construction of the request body and default RequestOptions internally.
        */
        PendingUploadRequest request = new PendingUploadRequest().setPendingUploadType(pendingUploadType);
        Response<BinaryData> response = pendingUploadWithResponse(name, version, BinaryData.fromObject(request), new RequestOptions());
        return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), response.getValue().toObject(PendingUploadResponse.class));
    }/**
     * Creates or updates a dataset version from a local file or folder path.
     * <p>
     * This method automatically detects if the provided path is a file or a directory, uploads the content accordingly,
     * and creates or updates the corresponding dataset version in the service. This streamlines the workflow for dataset
     * registration by handling upload, SAS negotiation, and dataset version creation in one call.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param path The local file or folder path to upload.
     * @return The created or updated dataset version, as either FileDatasetVersion or FolderDatasetVersion.
     * @throws IllegalArgumentException If the path does not exist or is not a file/folder.
     * @throws IOException If an I/O error occurs during folder traversal.
     */
    public Object createOrUpdateDatasetVersion(String name, String version, Path path) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder
          Reason: Developers often want to register a dataset from a local path without having to distinguish file vs. folder logic.
          This wrapper detects the path type, performs the correct upload workflow, and returns the appropriate dataset version object.
          It eliminates repetitive branching and error handling in user code.
        */
        if (Files.isRegularFile(path)) {
            return createDatasetWithFile(name, version, path);
        } else if (Files.isDirectory(path)) {
            return createDatasetWithFolder(name, version, path);
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
        }
    }
    
    /**
     * Creates or updates a dataset version from a local file, with optional description and tags.
     * <p>
     * This method provides a simplified workflow for the common case of registering a file as a dataset version,
     * allowing the caller to specify optional metadata (description, tags) without manually constructing model objects.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param filePath The local file path to upload.
     * @param description Optional description for the dataset version.
     * @param tags Optional tags for the dataset version.
     * @return The created or updated FileDatasetVersion.
     * @throws IllegalArgumentException If the path is not a file.
     */
    public FileDatasetVersion createDatasetVersionFromFile(
        String name,
        String version,
        Path filePath,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createDatasetWithFile, createOrUpdateDatasetVersionWithResponse
          Reason: Developers frequently want to register a file as a dataset version and attach metadata in one step.
          This wrapper exposes common metadata (description, tags) as parameters, removing the need to manually construct
          model objects or call multiple methods.
        */
        if (!Files.isRegularFile(filePath)) {
            throw new IllegalArgumentException("The provided path is not a file: " + filePath);
        }
        FileDatasetVersion datasetVersion = createDatasetWithFile(name, version, filePath);
        if (description != null) {
            datasetVersion.setDescription(description);
        }
        if (tags != null) {
            datasetVersion.setTags(tags);
        }
        // Update dataset version with metadata if provided
        if (description != null || tags != null) {
            createOrUpdateDatasetVersionWithResponse(
                name,
                version,
                BinaryData.fromObject(datasetVersion),
                new RequestOptions()
            );
        }
        return datasetVersion;
    }
    
    /**
     * Creates or updates a dataset version from a local folder, with optional description and tags.
     * <p>
     * This method provides a streamlined workflow for registering a folder as a dataset version,
     * allowing the caller to specify optional metadata (description, tags) without manually constructing model objects.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param folderPath The local folder path to upload.
     * @param description Optional description for the dataset version.
     * @param tags Optional tags for the dataset version.
     * @return The created or updated FolderDatasetVersion.
     * @throws IllegalArgumentException If the path is not a directory.
     * @throws IOException If an I/O error occurs during folder traversal.
     */
    public FolderDatasetVersion createDatasetVersionFromFolder(
        String name,
        String version,
        Path folderPath,
        String description,
        Map<String, String> tags
    ) throws IOException {
        /*
          Combined Methods: createDatasetWithFolder, createOrUpdateDatasetVersionWithResponse
          Reason: Developers frequently want to register a folder as a dataset version and attach metadata in one step.
          This wrapper exposes common metadata (description, tags) as parameters, removing the need to manually construct
          model objects or call multiple methods.
        */
        if (!Files.isDirectory(folderPath)) {
            throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
        }
        FolderDatasetVersion datasetVersion = createDatasetWithFolder(name, version, folderPath);
        if (description != null) {
            datasetVersion.setDescription(description);
        }
        if (tags != null) {
            datasetVersion.setTags(tags);
        }
        // Update dataset version with metadata if provided
        if (description != null || tags != null) {
            createOrUpdateDatasetVersionWithResponse(
                name,
                version,
                BinaryData.fromObject(datasetVersion),
                new RequestOptions()
            );
        }
        return datasetVersion;
    }/**
     * Retrieves a SAS credential for a dataset version and returns the parsed result directly, handling all necessary request setup.
     */
    public AssetCredentialResult getDatasetVersionSasCredential(String datasetName, String version) {
        /*
          Combined Methods: getCredentialsWithResponse, getCredentials
          Reason: Developers primarily want the SAS credential for a dataset version. This wrapper eliminates the need to manually construct RequestOptions, call the low-level method, and deserialize the response. It streamlines the common workflow of fetching credentials for a dataset version, providing a single, intent-revealing method with sensible defaults.
        */
        return getCredentials(datasetName, version);
    }
    
    /**
     * Retrieves a SAS credential for a dataset version, returning the full HTTP response for advanced scenarios.
     */
    public Response<AssetCredentialResult> getDatasetVersionSasCredentialWithResponse(String datasetName, String version, RequestOptions requestOptions) {
        /*
          Combined Methods: getCredentialsWithResponse
          Reason: Developers who need access to HTTP response metadata (headers, status, etc.) and a deserialized result can use this wrapper. It hides the BinaryData-to-object conversion, returning a strongly-typed response and reducing manual deserialization boilerplate.
        */
        Response<BinaryData> response = getCredentialsWithResponse(datasetName, version, requestOptions);
        AssetCredentialResult result = response.getValue().toObject(AssetCredentialResult.class);
        return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), result);
    }

    /********************* END OF GENERATED CODE *********************/

}
