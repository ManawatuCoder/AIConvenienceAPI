// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Creates or updates a DatasetVersion and immediately retrieves the resulting DatasetVersion.
     * <p>
     * This wrapper streamlines the common workflow of upserting a DatasetVersion and then fetching its latest state,
     * ensuring the returned object reflects any server-side transformations or defaults applied during creation or update.
     * </p>
     */
    public DatasetVersion upsertAndFetchDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        /*
          Combined Methods: createOrUpdateDatasetVersion, getDatasetVersion
          Reason: Developers frequently want to confirm the persisted state of a DatasetVersion after upsert, including any server-generated fields or normalization. This wrapper eliminates the need for two separate calls and reduces boilerplate, while preserving all underlying functionality.
        */
        createOrUpdateDatasetVersion(name, version, datasetVersion);
        return getDatasetVersion(name, version);
    }
    
    /**
     * Deletes a specific DatasetVersion if it exists, and returns whether the version was present and deleted.
     * <p>
     * This wrapper streamlines the common workflow of attempting to delete a DatasetVersion, 
     * and learning if the resource previously existed, without requiring manual exception handling for 404.
     * </p>
     */
    public boolean deleteDatasetVersionIfExists(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersion, getDatasetVersion
          Reason: Deleting a resource often requires first checking for existence or handling 404 exceptions. This wrapper provides a safe, intent-revealing pattern that returns true if the resource was deleted, or false if it did not exist, reducing error-prone boilerplate and improving clarity.
        */
        try {
            getDatasetVersion(name, version);
            deleteDatasetVersion(name, version);
            return true;
        } catch (ResourceNotFoundException ex) {
            return false;
        }
    }
    
    /**
     * Creates a new DatasetVersion with only required parameters.
     * <p>
     * This wrapper provides a streamlined way to create a DatasetVersion when only the required fields are known,
     * applying sensible defaults for optional parameters.
     * </p>
     */
    public DatasetVersion createDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion
          Reason: Creating a DatasetVersion often only requires a few fields, but the model has many optional properties. This wrapper reduces friction by allowing creation with only the required fields, encouraging best practices and reducing boilerplate.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }/**
     * Returns the latest version of a DatasetVersion for a given dataset name.
     *
     * <p>This method simplifies the common workflow of retrieving the most recent version of a dataset, 
     * which would otherwise require listing all versions and then manually determining the latest.</p>
     *
     * @param name The name of the dataset.
     * @return The latest DatasetVersion for the specified dataset, or null if none exist.
     */
    public DatasetVersion getLatestDatasetVersion(String name) {
        /*
          Combined Methods: listDatasetVersions
          Reason: Developers often want the latest version of a dataset. This wrapper encapsulates the common pattern of retrieving all versions and selecting the latest, reducing boilerplate and potential errors in sorting/filtering.
        */
        PagedIterable<DatasetVersion> versions = listDatasetVersions(name);
        DatasetVersion latest = null;
        for (DatasetVersion version : versions) {
            if (latest == null || version.getVersion().compareTo(latest.getVersion()) > 0) {
                latest = version;
            }
        }
        return latest;
    }
    
    /**
     * Returns a mapping from dataset name to its latest DatasetVersion for all datasets.
     *
     * <p>This method streamlines the workflow of retrieving the latest version for every dataset, 
     * which would otherwise require listing all latest versions and grouping them manually.</p>
     *
     * @return A map where the key is the dataset name and the value is its latest DatasetVersion.
     */
    public Map<String, DatasetVersion> listLatestDatasetVersionsByName() {
        /*
          Combined Methods: listLatestDatasetVersions
          Reason: Developers frequently need to work with the latest version of each dataset. This wrapper provides a ready-to-use mapping, reducing the need for manual iteration and grouping.
        */
        Map<String, DatasetVersion> result = new HashMap<>();
        for (DatasetVersion version : listLatestDatasetVersions()) {
            result.put(version.getName(), version);
        }
        return result;
    }/**
     * Starts or retrieves a pending upload for a dataset version, using only the required parameters.
     * Provides sensible defaults for optional parameters and request options, streamlining the common case.
     */
    public PendingUploadResponse startPendingUpload(String datasetName, String version) {
        /*
          Combined Methods: pendingUpload
          Reason: Developers often want to initiate a dataset upload with minimal configuration. This wrapper allows starting a pending upload with only the required dataset name and version, automatically constructing a PendingUploadRequest with default type "BlobReference" and omitting optional fields. This eliminates the need for manual request object construction and reduces boilerplate for the most common scenario.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType("BlobReference");
        return pendingUpload(datasetName, version, request);
    }
    
    /**
     * Starts or retrieves a pending upload for a dataset version, specifying a connection name.
     * Simplifies the process by allowing the developer to provide only the connection name in addition to required parameters.
     */
    public PendingUploadResponse startPendingUpload(String datasetName, String version, String connectionName) {
        /*
          Combined Methods: pendingUpload
          Reason: Many users need to specify a connection name for storage, but don't want to manually build the request object. This wrapper allows specifying the connection name directly, sets the required pendingUploadType to "BlobReference", and omits other optional fields, reducing repetitive code and clarifying intent.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType("BlobReference")
            .setConnectionName(connectionName);
        return pendingUpload(datasetName, version, request);
    }
    
    /**
     * Starts or retrieves a pending upload for a dataset version, optionally specifying a connection name and a pending upload ID.
     * This overload is useful for resuming or referencing an existing pending upload, while still minimizing boilerplate.
     */
    public PendingUploadResponse startPendingUpload(String datasetName, String version, String connectionName, String pendingUploadId) {
        /*
          Combined Methods: pendingUpload
          Reason: When resuming or referencing an existing pending upload, developers need to specify both connection name and pending upload ID. This wrapper enables that scenario directly, without requiring manual construction of the request object, streamlining a common workflow.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType("BlobReference")
            .setConnectionName(connectionName)
            .setPendingUploadId(pendingUploadId);
        return pendingUpload(datasetName, version, request);
    }/**
     * Creates or updates a dataset version from a local file or folder path.
     * <p>
     * This method intelligently determines whether the provided path is a file or directory,
     * uploads the content to the service, and creates or updates the corresponding dataset version.
     * It eliminates the need for the developer to manually distinguish between file and folder uploads,
     * and handles all necessary upload and registration steps.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier for the dataset.
     * @param path The local file or folder path to upload.
     * @return The created or updated dataset version (FileDatasetVersion or FolderDatasetVersion).
     * @throws IllegalArgumentException If the path is neither a file nor a directory.
     * @throws IOException If an I/O error occurs during folder traversal.
     */
    public Object upsertDatasetVersionFromPath(String name, String version, Path path) throws IOException {
        /*
          Combined Methods: createDatasetWithFile, createDatasetWithFolder, pendingUpload, createOrUpdateDatasetVersionWithResponse
          Reason: Developers often want to register a dataset version from a local path, but must currently distinguish between file and folder uploads and manually invoke different methods. This wrapper streamlines the workflow by automatically handling both cases, reducing cognitive load and boilerplate, and aligning with the intent of "register this path as a dataset version".
        */
        if (Files.isRegularFile(path)) {
            // Delegate to file upload logic
            return createDatasetWithFile(name, version, path);
        } else if (Files.isDirectory(path)) {
            // Delegate to folder upload logic
            return createDatasetWithFolder(name, version, path);
        } else {
            throw new IllegalArgumentException("The provided path is neither a file nor a directory: " + path);
        }
    }
    
    /**
     * Creates or updates a dataset version from a local file, with optional metadata.
     * <p>
     * This method uploads a file and registers it as a dataset version, allowing the caller to specify
     * description and tags in a single call. It provides sensible defaults for optional metadata, reducing
     * the number of steps required for common scenarios.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier for the dataset.
     * @param filePath The local file path to upload.
     * @param description Optional description for the dataset version.
     * @param tags Optional tags to associate with the dataset version.
     * @return The created or updated FileDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a file.
     */
    public FileDatasetVersion upsertFileDatasetVersion(String name, String version, Path filePath, String description, Map<String, String> tags) {
        /*
          Combined Methods: createDatasetWithFile, createOrUpdateDatasetVersionWithResponse
          Reason: Developers often want to upload a file as a dataset version and set metadata (description, tags) in one step. The low-level API requires multiple calls and manual object construction. This wrapper streamlines the workflow, providing a single entry point for the common scenario of file-based dataset registration with metadata.
        */
        if (!Files.isRegularFile(filePath)) {
            throw new IllegalArgumentException("The provided path is not a file: " + filePath);
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = new FileDatasetVersion()
            .setDataUri(blobClient.getBlobUrl())
            .setName(name)
            .setVersion(version)
            .setDescription(description)
            .setTags(tags);
        FileDatasetVersion result = this
            .createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(datasetVersion), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return result;
    }
    
    /**
     * Creates or updates a dataset version from a local folder, with optional metadata.
     * <p>
     * This method uploads all files in the specified folder (recursively) and registers them as a folder dataset version,
     * allowing the caller to specify description and tags in a single call. It handles all upload and registration steps,
     * reducing boilerplate for common folder-based dataset registration scenarios.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier for the dataset.
     * @param folderPath The local folder path to upload.
     * @param description Optional description for the dataset version.
     * @param tags Optional tags to associate with the dataset version.
     * @return The created or updated FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException If an I/O error occurs during folder traversal.
     */
    public FolderDatasetVersion upsertFolderDatasetVersion(String name, String version, Path folderPath, String description, Map<String, String> tags) throws IOException {
        /*
          Combined Methods: createDatasetWithFolder, createOrUpdateDatasetVersionWithResponse
          Reason: Developers often want to upload a folder as a dataset version and set metadata (description, tags) in one step. The low-level API requires multiple calls and manual object construction. This wrapper streamlines the workflow, providing a single entry point for the common scenario of folder-based dataset registration with metadata.
        */
        if (!Files.isDirectory(folderPath)) {
            throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
        }
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = new FolderDatasetVersion()
            .setDataUri(containerUrl)
            .setName(name)
            .setVersion(version)
            .setDescription(description)
            .setTags(tags);
        FolderDatasetVersion result = this
            .createOrUpdateDatasetVersionWithResponse(name, version, BinaryData.fromObject(datasetVersion), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return result;
    }/**
     * Obtains a SAS URI for the dataset version's blob, ready for direct use in storage operations.
     * <p>
     * This method streamlines the process of retrieving a SAS URI for a dataset version's blob, abstracting away
     * the need to manually extract and parse the credential details from the response model.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return The SAS URI string for the dataset version's blob.
     */
    public String getDatasetVersionBlobSasUri(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Developers commonly want to access the SAS URI directly for blob operations, but the low-level API
                  requires navigating through nested model properties. This wrapper provides a direct, intent-revealing
                  method to retrieve the SAS URI, reducing boilerplate and improving clarity for the most common use case.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null || result.getBlobReference().getCredential() == null) {
            throw new IllegalStateException("Unable to retrieve SAS URI: missing credential information.");
        }
        return result.getBlobReference().getCredential().getSasUri();
    }
    
    /**
     * Obtains the storage account ARM resource ID associated with a dataset version's blob.
     * <p>
     * This method simplifies access to the storage account ARM ID, which is often needed for resource management
     * or auditing, by extracting it from the nested credential result model.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return The storage account ARM resource ID string.
     */
    public String getDatasetVersionStorageAccountArmId(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Accessing the storage account ARM ID is a common scenario for resource tracking or permissions.
                  The raw API requires manual traversal of nested models. This wrapper provides a direct, intent-based
                  method to retrieve the ARM ID, reducing repetitive code and clarifying developer intent.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null) {
            throw new IllegalStateException("Unable to retrieve storage account ARM ID: missing blob reference.");
        }
        return result.getBlobReference().getStorageAccountArmId();
    }
    
    /**
     * Retrieves all credential details for a dataset version's blob in a strongly-typed result.
     * <p>
     * This method provides a streamlined way to obtain all relevant credential information (blob URI, storage account ARM ID,
     * SAS URI, and credential type) in a single call, returning a strongly-typed result for immediate use.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @return An object containing blobUri, storageAccountArmId, sasUri, and credentialType.
     */
    public DatasetBlobAccessInfo getDatasetVersionBlobAccessInfo(String name, String version) {
        /*
          Combined Methods: getCredentials
          Reason: Developers often need all relevant access details for a dataset version's blob for downstream operations.
                  The low-level API returns a nested model, requiring manual extraction of each property. This wrapper
                  returns a simple, purpose-built POJO containing all relevant fields, reducing boilerplate and clarifying intent.
        */
        AssetCredentialResult result = getCredentials(name, version);
        if (result == null || result.getBlobReference() == null || result.getBlobReference().getCredential() == null) {
            throw new IllegalStateException("Unable to retrieve blob access info: missing credential information.");
        }
        return new DatasetBlobAccessInfo(
            result.getBlobReference().getBlobUri(),
            result.getBlobReference().getStorageAccountArmId(),
            result.getBlobReference().getCredential().getSasUri(),
            result.getBlobReference().getCredential().getType()
        );
    }
    
    /**
     * POJO representing all relevant access information for a dataset version's blob.
     */
    public static class DatasetBlobAccessInfo {
        private final String blobUri;
        private final String storageAccountArmId;
        private final String sasUri;
        private final String credentialType;
    
        public DatasetBlobAccessInfo(String blobUri, String storageAccountArmId, String sasUri, String credentialType) {
            this.blobUri = blobUri;
            this.storageAccountArmId = storageAccountArmId;
            this.sasUri = sasUri;
            this.credentialType = credentialType;
        }
    
        public String getBlobUri() {
            return blobUri;
        }
    
        public String getStorageAccountArmId() {
            return storageAccountArmId;
        }
    
        public String getSasUri() {
            return sasUri;
        }
    
        public String getCredentialType() {
            return credentialType;
        }
    }

    /********************* END OF GENERATED CODE *********************/

}
