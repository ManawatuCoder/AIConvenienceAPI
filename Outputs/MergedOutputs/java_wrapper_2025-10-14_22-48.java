// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.ai.projects;

import com.azure.ai.projects.implementation.DatasetsImpl;
import com.azure.ai.projects.implementation.JsonMergePatchHelper;
import com.azure.ai.projects.models.AssetCredentialResult;
import com.azure.ai.projects.models.DatasetVersion;
import com.azure.ai.projects.models.FileDatasetVersion;
import com.azure.ai.projects.models.FolderDatasetVersion;
import com.azure.ai.projects.models.PendingUploadRequest;
import com.azure.ai.projects.models.PendingUploadResponse;
import com.azure.ai.projects.models.SasCredential;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.logging.ClientLogger;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobClientBuilder;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;

/**
 * Initializes a new instance of the synchronous AIProjectClient type.
 */
@ServiceClient(builder = AIProjectClientBuilder.class)
public final class DatasetsClient {

    private final ClientLogger logger = new ClientLogger(DatasetsClient.class);

    @Generated
    private final DatasetsImpl serviceClient;

    /**
     * Initializes an instance of DatasetsClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    DatasetsClient(DatasetsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }

    /**
     * List all versions of the given DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listDatasetVersions(String name, RequestOptions requestOptions) {
        return this.serviceClient.listDatasetVersions(name, requestOptions);
    }

    /**
     * List the latest version of each DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listLatestDatasetVersions(RequestOptions requestOptions) {
        return this.serviceClient.listLatestDatasetVersions(requestOptions);
    }

    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }


    /********************* GENERATED WRAPPER CODE *********************/
    /**
     * Retrieves all versions of a dataset and returns them as a List for easier consumption.
     *
     * <p>This method fetches all pages of DatasetVersion items for the specified dataset name and collects them into a List.
     * This is useful for scenarios where the developer wants to work with all dataset versions in-memory, rather than dealing with paged iteration.</p>
     *
     * @param name The name of the dataset resource.
     * @return List of all DatasetVersion items for the given dataset name.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public List<DatasetVersion> listAllDatasetVersions(String name) {
        /*
          Combined Methods: listDatasetVersions(String name) + iteration and collection to List
          Reason: Developers often want all results as a List for further processing, testing, or UI display, and should not have to manually iterate and collect paged results.
        */
        PagedIterable<DatasetVersion> paged = listDatasetVersions(name);
        List<DatasetVersion> allVersions = new ArrayList<>();
        for (DatasetVersion version : paged) {
            allVersions.add(version);
        }
        return allVersions;
    }
    
    /**
     * Retrieves the latest version of each dataset and returns them as a List for easier consumption.
     *
     * <p>This method fetches all pages of the latest DatasetVersion items and collects them into a List.
     * Useful for scenarios where developers want to work with all latest dataset versions in-memory, without manual paging.</p>
     *
     * @return List of latest DatasetVersion items.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    public List<DatasetVersion> listAllLatestDatasetVersions() {
        /*
          Combined Methods: listLatestDatasetVersions() + iteration and collection to List
          Reason: Developers frequently want to process all latest versions at once, and this wrapper eliminates the need for manual iteration and collection from paged responses.
        */
        PagedIterable<DatasetVersion> paged = listLatestDatasetVersions();
        List<DatasetVersion> allLatestVersions = new ArrayList<>();
        for (DatasetVersion version : paged) {
            allLatestVersions.add(version);
        }
        return allLatestVersions;
    }/**
     * Retrieves a specific version of a DatasetVersion, returning the strongly-typed DatasetVersion object.
     * <p>
     * This method simplifies retrieval by automatically handling request options and deserialization.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @return The specific version of the DatasetVersion.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by the server.
     * @throws ClientAuthenticationException if authentication fails.
     * @throws ResourceNotFoundException if the resource is not found.
     * @throws ResourceModifiedException if the resource is modified concurrently.
     * @throws RuntimeException for all other failures.
     */
    public DatasetVersion getDatasetVersion(String name, String version) {
        /*
          Combined Methods: getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions)
          Reason: Provides a streamlined, developer-friendly way to retrieve a DatasetVersion by name and version,
          automatically handling request options and deserialization. This eliminates the need for the user to manually
          construct RequestOptions or handle BinaryData conversion, which are common sources of boilerplate and confusion.
        */
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }
    
    /**
     * Retrieves a specific version of a DatasetVersion, returning the full HTTP response including headers and status.
     * <p>
     * This method is intended for advanced scenarios where the developer needs access to HTTP metadata.
     * </p>
     *
     * @param name The name of the dataset resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @return The HTTP response containing the DatasetVersion as BinaryData.
     * @throws HttpResponseException if the request is rejected by the server.
     * @throws ClientAuthenticationException if authentication fails.
     * @throws ResourceNotFoundException if the resource is not found.
     * @throws ResourceModifiedException if the resource is modified concurrently.
     */
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version) {
        /*
          Combined Methods: getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions)
          Reason: Provides a convenience overload that supplies default RequestOptions, reducing boilerplate for the
          common case where custom request options are not needed. This aligns with Azure SDK guidelines for simple
          overloads and improves usability for typical scenarios.
        */
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions);
    }/**
     * Starts a new pending upload of a dataset for a specific version, using only the required parameters.
     * <p>
     * This overload streamlines the process by requiring only the resource name, version, and the required pending upload type.
     * Optional fields such as pendingUploadId and connectionName are omitted for common scenarios.
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: Most common workflow only requires name, version, and pendingUploadType. This wrapper eliminates the need for the user to construct a PendingUploadRequest object for the simplest use case, reducing boilerplate and making the API more approachable for typical scenarios.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts or resumes a pending upload of a dataset for a specific version, optionally specifying an existing pendingUploadId and connectionName.
     * <p>
     * This overload streamlines the process by allowing the user to specify only the fields they care about, while handling the construction of the PendingUploadRequest.
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param pendingUploadId The optional existing pending upload ID (may be null).
     * @param connectionName The optional connection name (may be null).
     * @return The response for the pending upload request.
     */
    public PendingUploadResponse startOrResumePendingUpload(
        String name,
        String version,
        String pendingUploadType,
        String pendingUploadId,
        String connectionName
    ) {
        /*
          Combined Methods: pendingUpload(String, String, PendingUploadRequest)
          Reason: This wrapper abstracts away the manual creation of PendingUploadRequest and its optional fields, letting developers focus on their intent (start or resume an upload) and reducing repetitive setup code.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType)
            .setPendingUploadId(pendingUploadId)
            .setConnectionName(connectionName);
        return pendingUpload(name, version, request);
    }
    
    /**
     * Starts a new pending upload of a dataset for a specific version and returns the full HTTP response, using only the required parameters.
     * <p>
     * This overload is intended for scenarios where the developer needs access to HTTP response metadata, but does not want to manually construct the request body.
     * </p>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
     * @param requestOptions The options to configure the HTTP request before sending.
     * @return The HTTP response for the pending upload request.
     */
    public Response<BinaryData> startPendingUploadWithResponse(
        String name,
        String version,
        String pendingUploadType,
        RequestOptions requestOptions
    ) {
        /*
          Combined Methods: pendingUploadWithResponse(String, String, BinaryData, RequestOptions)
          Reason: This wrapper provides a streamlined way to access the full HTTP response for the most common scenario, reducing the need for manual BinaryData and request object construction.
        */
        PendingUploadRequest request = new PendingUploadRequest()
            .setPendingUploadType(pendingUploadType);
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(request), requestOptions);
    }/**
     * Creates or updates a dataset version from a local file in a single call.
     * <p>
     * This method handles all steps required to upload a local file as a dataset version, including:
     * <ul>
     *   <li>Validating the file path</li>
     *   <li>Requesting a pending upload and obtaining upload credentials</li>
     *   <li>Uploading the file to the service</li>
     *   <li>Registering the dataset version with the uploaded file URI</li>
     * </ul>
     * <p>
     * This eliminates the need for the developer to manually coordinate multiple service calls and blob uploads.
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier for the dataset.
     * @param filePath The path to the local file to upload.
     * @return The created or updated FileDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a file.
     */
    public FileDatasetVersion uploadFileAsDatasetVersion(String name, String version, Path filePath) {
        /*
          Combined Methods: pendingUpload, BlobClient.upload, createOrUpdateDatasetVersionWithResponse
          Reason: This wrapper abstracts the multi-step, error-prone workflow of uploading a file and registering it as a dataset version,
          reducing developer boilerplate and potential for misuse. It represents the high-level intent of "upload this file as a dataset version".
        */
        if (!Files.isRegularFile(filePath)) {
            throw new IllegalArgumentException("The provided path is not a file: " + filePath);
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }
    
    /**
     * Creates or updates a dataset version from a local folder in a single call.
     * <p>
     * This method handles all steps required to upload all files in a folder as a dataset version, including:
     * <ul>
     *   <li>Validating the folder path</li>
     *   <li>Requesting a pending upload and obtaining upload credentials</li>
     *   <li>Uploading all files in the folder (preserving relative paths)</li>
     *   <li>Registering the dataset version with the uploaded folder URI</li>
     * </ul>
     * <p>
     * This eliminates the need for the developer to manually coordinate multiple service calls and blob uploads.
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier for the dataset.
     * @param folderPath The path to the local folder to upload.
     * @return The created or updated FolderDatasetVersion.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException If an I/O error occurs during file access.
     */
    public FolderDatasetVersion uploadFolderAsDatasetVersion(String name, String version, Path folderPath) throws IOException {
        /*
          Combined Methods: pendingUpload, BlobClient.upload (for each file), createOrUpdateDatasetVersionWithResponse
          Reason: This wrapper abstracts the multi-step workflow of uploading a folder and registering it as a dataset version,
          reducing developer boilerplate and potential for error. It represents the high-level intent of "upload this folder as a dataset version".
        */
        if (!Files.isDirectory(folderPath)) {
            throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
        }
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }/**
     * Deletes a specific version of a dataset, handling common error scenarios and providing a clear, intent-based API.
     *
     * <p>This method abstracts away the need to manually construct {@link RequestOptions} and directly calls the lower-level
     * deleteDatasetVersionWithResponse method, surfacing only the most relevant parameters for typical delete operations.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException if parameters fail validation.
     * @throws HttpResponseException if the request is rejected by the server.
     * @throws ClientAuthenticationException if authentication fails.
     * @throws ResourceNotFoundException if the specified dataset version does not exist.
     * @throws ResourceModifiedException if the dataset version cannot be deleted due to a conflict.
     * @throws RuntimeException for all other wrapped checked exceptions if the request fails to be sent.
     */
    public void deleteDatasetVersionIfExists(String name, String version) {
        /*
          Combined Methods: deleteDatasetVersion and deleteDatasetVersionWithResponse
          Reason: This wrapper provides a clear, intent-driven API for deleting a dataset version, 
          eliminating the need for developers to manually construct RequestOptions or handle response objects 
          when they simply want to delete a version. It also clarifies that the operation is safe to call 
          even if the version may not exist, aligning with common developer expectations for delete operations.
        */
        try {
            deleteDatasetVersion(name, version);
        } catch (ResourceNotFoundException ex) {
            // No-op: Deleting a non-existent resource is considered successful in most developer workflows.
        }
    }/**
     * Creates or updates a DatasetVersion with the given name and version, using only the required fields.
     * <p>
     * This overload provides a streamlined way to create or update a DatasetVersion when only the essential fields are needed.
     * Optional fields (description, tags, etc.) are omitted for simplicity. For advanced scenarios, use the full method.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(String name, String version, String type, String dataUri) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: Developers commonly want to create or update a DatasetVersion with just the required fields (type, dataUri, name, version).
          This wrapper eliminates the need to manually construct a DatasetVersion object for the most basic scenario,
          reducing boilerplate and aligning with the options pattern for simple creation.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with common optional fields.
     * <p>
     * This overload allows creation or update of a DatasetVersion with required fields and commonly-used optional fields
     * (description and tags), minimizing the need for verbose model construction in typical scenarios.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: This wrapper targets the common workflow where developers want to specify description and tags
          in addition to the required fields, without manually building the DatasetVersion model.
          It streamlines the process and reduces repetitive code.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }
    
    /**
     * Creates or updates a DatasetVersion with all available fields, providing sensible defaults for optional parameters.
     * <p>
     * This overload is intended for scenarios where developers want to specify all possible fields, but don't want to manually
     * construct the DatasetVersion object. Optional parameters can be passed as null if not needed.
     * </p>
     */
    public DatasetVersion upsertDatasetVersion(
        String name,
        String version,
        String type,
        String dataUri,
        Boolean isReference,
        String connectionName,
        String id,
        String description,
        Map<String, String> tags
    ) {
        /*
          Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
          Reason: This wrapper provides a comprehensive yet convenient way to create or update a DatasetVersion,
          allowing developers to specify all fields in a single call, reducing manual model construction and boilerplate.
        */
        DatasetVersion datasetVersion = new DatasetVersion()
            .setName(name)
            .setVersion(version)
            .setType(type)
            .setDataUri(dataUri)
            .setIsReference(isReference)
            .setConnectionName(connectionName)
            .setId(id)
            .setDescription(description)
            .setTags(tags);
        return createOrUpdateDatasetVersion(name, version, datasetVersion);
    }/**
     * Retrieves the SAS credential (including SAS URI and storage account details) for a specific dataset version,
     * returning the strongly-typed result directly for ease of use.
     *
     * <p>This method streamlines access to the storage credentials for a dataset version, hiding the need to manually
     * construct request options or deserialize the response.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier of the dataset.
     * @return The credential result containing SAS URI and related storage details.
     */
    public AssetCredentialResult getDatasetStorageCredentials(String name, String version) {
        /*
          Combined Methods: getCredentialsWithResponse(String, String, RequestOptions)
          Reason: This wrapper provides a clear, intent-driven method for retrieving dataset storage credentials.
                  It eliminates the need for the developer to manually create RequestOptions or deserialize the BinaryData,
                  aligning with the guideline to return logical entities for common workflows.
                  This method is especially useful for the most common scenario—simply retrieving the credentials.
        */
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }
    
    /**
     * Retrieves the SAS URI string for the blob associated with a specific dataset version.
     *
     * <p>This method abstracts away the details of parsing the full credential result, returning just the SAS URI
     * for direct use in storage operations.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier of the dataset.
     * @return The SAS URI string for the dataset version's blob.
     */
    public String getDatasetBlobSasUri(String name, String version) {
        /*
          Combined Methods: getCredentialsWithResponse(String, String, RequestOptions)
          Reason: This wrapper targets the common use case where a developer needs only the SAS URI for direct storage access,
                  not the full credential structure. It parses and returns the SAS URI directly, reducing boilerplate and
                  improving clarity for this frequent workflow.
        */
        RequestOptions requestOptions = new RequestOptions();
        AssetCredentialResult result = getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
        return result.getBlobReference().getCredential().getSasUri();
    }
    
    /**
     * Retrieves the SAS credential for a dataset version, allowing the caller to specify custom request options.
     *
     * <p>This overload provides a strongly-typed result while still supporting advanced scenarios where custom
     * request options are needed.</p>
     *
     * @param name The name of the dataset resource.
     * @param version The version identifier of the dataset.
     * @param requestOptions Custom options for the HTTP request.
     * @return The credential result containing SAS URI and related storage details.
     */
    public AssetCredentialResult getDatasetStorageCredentials(String name, String version, RequestOptions requestOptions) {
        /*
          Combined Methods: getCredentialsWithResponse(String, String, RequestOptions)
          Reason: This wrapper provides a strongly-typed result (AssetCredentialResult) even when custom RequestOptions are needed,
                  reducing the need for developers to manually deserialize BinaryData in advanced scenarios.
        */
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }

    /********************* END OF GENERATED CODE *********************/

}
