Java Convenience Wrapper Generated by Azure OpenAI
Generated: 2025-10-14 22:22:39



================================================================================
Prompt 1: Method and Guideline Analysis
================================================================================

Context: You are analyzing the attached codegen methods from a client class, along with a list of Java Azure SDK Design Guidelines headers.

Your tasks:
1. Identify potential patterns across these methods that could be optimized to improve developer experience 
   (e.g. similar operations that could be combined, consistent parameter patterns, repetitive return processing, 
   avoiding low-level data types like byte streams).
2. From the list of guideline headers, select which guidelines are most relevant to the identified methods.

Instructions:
- Only consider patterns relevant to developer convenience. Ignore low-level protocol details.
- Evaluate whether there is any true convenience to be added.
- You will generate wrappers over multiple requests, so any methods you wish to wrap together should be grouped together in your response.
- Each group will be sent as its own prompt alongside the entire list of requested guidelines; Large grouping is acceptable, and can be desireable for reduced LLM costs.
- Duplicates methods through groups are undesireable; Coallescing of groups is preferred to duplicate methods.
- Duplicate guidelines are completely acceptable, it is desired that you have what you need to output quality.
- If no patterns are found, return only the string "no".
- If patterns are found, return a JSON object in the format:

[
  {
    "methods": ["foo", "bar", ...],
    "guidelines": ["Header 1", "Header 3", ...]
  },
  {
    "methods": ["foobar", "baz", ...],
    "guidelines": ["Header 2", "Header 3", ...]
  },
  ...
]

Notes:
- Do NOT include any explanations or commentary.
- Do not put generated code into a class. You must only return the names as requested.
- If there is no real convenience to be added, ignore all steps and return only the word "no".

Method names:
```
[listDatasetVersions(, pendingUploadWithResponse(, getDatasetVersion(, getDatasetVersionWithResponse(, pendingUpload(, createDatasetWithFile(, createDatasetWithFolder(, deleteDatasetVersionWithResponse(, createOrUpdateDatasetVersionWithResponse(, deleteDatasetVersion(, listLatestDatasetVersions(, createOrUpdateDatasetVersion(, getCredentialsWithResponse(, getCredentials(]
```

Guideline headers:
"""
Introduction
Design Principles
General Guidelines
Support for non-HTTP Protocols
Azure SDK API Design
Service Client
Sync Service Clients
Async Service Clients
Service Client Creation
Service Versions
Service Methods
Non-Service Methods
Cancellation
Return Types
Option Parameters
Parameter Validation
Methods Returning Collections (Paging)
Methods Invoking Long-Running Operations
Conditional Request Methods
Hierarchical Clients
Model Types
Enumerations
Using Azure Core Types
Using Primitive Types
Exceptions
Authentication
Namespaces
Example Namespaces
Support for Mocking
Maven
Service-Specific Common Libraries
Java 9 Modules
Versioning
Client Version Numbers
Dependencies
Native code
Documentation
General guidelines
Samples
Java API Best Practices
Naming Patterns

"""
--------------------------------------------------------------------------------

Step 1 Output:
[
  {
    "methods": [
      "listDatasetVersions",
      "listLatestDatasetVersions"
    ],
    "guidelines": [
      "Methods Returning Collections (Paging)",
      "Service Methods",
      "Return Types",
      "Naming Patterns"
    ]
  },
  {
    "methods": [
      "getDatasetVersion",
      "getDatasetVersionWithResponse"
    ],
    "guidelines": [
      "Service Methods",
      "Return Types",
      "Option Parameters",
      "Naming Patterns"
    ]
  },
  {
    "methods": [
      "createDatasetWithFile",
      "createDatasetWithFolder"
    ],
    "guidelines": [
      "Service Methods",
      "Return Types",
      "Option Parameters",
      "Naming Patterns"
    ]
  },
  {
    "methods": [
      "pendingUpload",
      "pendingUploadWithResponse"
    ],
    "guidelines": [
      "Service Methods",
      "Return Types",
      "Option Parameters",
      "Naming Patterns"
    ]
  },
  {
    "methods": [
      "createOrUpdateDatasetVersion",
      "createOrUpdateDatasetVersionWithResponse"
    ],
    "guidelines": [
      "Service Methods",
      "Return Types",
      "Option Parameters",
      "Naming Patterns"
    ]
  },
  {
    "methods": [
      "deleteDatasetVersion",
      "deleteDatasetVersionWithResponse"
    ],
    "guidelines": [
      "Service Methods",
      "Return Types",
      "Option Parameters",
      "Naming Patterns"
    ]
  },
  {
    "methods": [
      "getCredentials",
      "getCredentialsWithResponse"
    ],
    "guidelines": [
      "Authentication",
      "Service Methods",
      "Return Types",
      "Option Parameters",
      "Naming Patterns"
    ]
  }
]
================================================================================


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * List all versions of the given DatasetVersion.
     *
     * @param name The name of the resource.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listDatasetVersions(String name) {
        // Generated convenience method for listDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listDatasetVersions(name, requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }



    /**
     * List the latest version of each DatasetVersion.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of DatasetVersion items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<DatasetVersion> listLatestDatasetVersions() {
        // Generated convenience method for listLatestDatasetVersions
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient.listLatestDatasetVersions(requestOptions)
            .mapPage(bodyItemValue -> bodyItemValue.toObject(DatasetVersion.class));
    }



```
Design Guidelines:
"""
Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Methods Returning Collections (Paging)
Many Azure REST APIs return collections of data in batches or pages. A client library will expose such APIs as special enumerable types PagedIterable<T> or PagedFlux<T> (or one of their parent types), for synchronous and asynchronous APIs, respectively. These types are located in the azure-core library.
✅ DO return PagedIterable<T> from service methods in synchronous that return a collection of items. For example, the configuration service sync client should offer the following API:
public final class ConfigurationClient {
    // synchronous API returning a PagedIterable of ConfigurationSetting instances
    public PagedIterable<ConfigurationSetting> listSettings(...) {
        ...
    }
}
PagedIterable allows developers to write code that works using the standard for loop syntax (as it is an Iterable), and also to work with a Java Stream (as there is a stream() method). Consumers may also call streamByPage() and iterableByPage() methods to work on page boundaries. Subclasses of these types are acceptable as return types too, so long as the naming convention generally follows the pattern <serviceName>PagedIterable or <operation>PagedFlux.
⛔️ DO NOT return other collection types for sync APIs that return collections (for example, do not return List, Stream, Iterable, or Iterator).
✅ DO return PagedFlux<T> (or an appropriately-named subclass) for asynchronous APIs that expose a collection of items. Even if the service does not support pagination, always return PagedFlux<T>, as it allows for consumers to retrieve response information in a consistent manner.
public final class ConfigurationAsyncClient {

    // asynchronous API returning a PagedFlux of ConfigurationSetting instances
    public PagedFlux<ConfigurationSetting> listSettings(SettingSelector options, Context context) {
        // The first lambda is a Supplier<PagedResponse<T>> returning the first page of results
        // as a Mono<PagedResponse<T>>.
        // The second lambda is a Function<String, Mono<PagedResponse<T>>>, returning a
        // Mono<PagedResponse<T>> representing a page based on the provided continuationToken.
        return new PagedFlux<>(
            () -> listFirstPageSettings(options, context),
            continuationToken -> listNextPageSettings(contextWithSpanName, continuationToken));
    }
}
Consumers of this API can consume individual items by treating the response as a Flux<T>:
client.listSettings(..)
      .subscribe(item -> System.out.println("Processing item " + item));
The consumer may process items page-by-page instead:
client.listSettings(..)
      .byPage()
      .subscribe(page -> {
        // page is a PagedResponse, which implements Page and Response, so there exists:
        //  * List<T> of items,
        //  * continuationToken (represented as a String),
        //  * Status code,
        //  * HTTP headers,
        //  * HTTP request
        System.out.println("Processing page " + page)
});
The PagedFlux.byPage() offers an overload to accept a continuationToken string, which will begin the returned Flux at the page specified by this token.
✔️ YOU MAY subclass the azure-core paged and iterable APIs, where appropriate, to offer additional, service specific API to users. If this is done, the subtype must be named as it currently is, prefixed with the name of the service. For example, SearchPagedFlux and SearchPagedIterable. Subtypes are expected to be placed within a util package existing within the root package.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * Get the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the specific version of the DatasetVersion.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion getDatasetVersion(String name, String version) {
        // Generated convenience method for getDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
    }


    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }



    /**
     * Get the specific version of the DatasetVersion.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to retrieve.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the specific version of the DatasetVersion along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getDatasetVersionWithResponse(String name, String version,
        RequestOptions requestOptions) {
        return this.serviceClient.getDatasetVersionWithResponse(name, version, requestOptions);
    }



```
Design Guidelines:
"""
Option Parameters
Service methods fall into two main groups when it comes to the number and complexity of parameters they accept:
Service Methods with simple inputs, simple methods for short Service Methods with complex inputs, complex methods for short
Simple methods are methods that take up to six parameters, with most of the parameters being simple primitive types. Complex methods are methods that take a larger number of parameters and typically correspond to REST APIs with complex request payloads.
Simple methods should follow standard Java best practices for parameter list and overload design.
Complex methods should introduce an option parameter to represent the request payload. Consideration can subsequently be made for providing simpler convenience overloads for the most common scenarios. This is referred to in this document as the ‘options pattern’, and is demonstrated in the code below:
public class BlobContainerClient {

    // simple service methods
    public BlobInfo uploadBlob(String blobName, byte[] content);
    public Response<BlobInfo> uploadBlobWithResponse(String blobName, byte[] content, Context context);

    // complex service methods, note the introduction of the 'CreateBlobOptions' type
    public BlobInfo createBlob(CreateBlobOptions options);
    public Response<BlobInfo> createBlobWithResponse(CreateBlobOptions options, Context context);

    // convenience overload[s]
    public BlobInfo createBlob(String blobName);
}

@Fluent
public class CreateBlobOptions {
    private String blobName;
    private PublicAccessType access;
    private Map<String, String> metadata;

    // Constructor enforces the requirement that blobName is always set
    public CreateBlobOptions(String blobName) {
        this.blobName = blobName;
    }

    public String getBlobName() {
        return blobName;
    }

    public CreateBlobOptions setAccess(PublicAccessType access) {
        this.access = access;
        return this;
    }

    public PublicAccessType getAccess() {
        return access;
    }

    public CreateBlobOptions setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }
}
✅ DO name the options type after the name of the service method it is used for, such that the type is named <operation>Options. For example, above the method was createBlob, and so the options type was named CreateBlobOptions.
✅ DO use the options parameter pattern for complex service methods.
✔️ YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future.
✔️ YOU MAY add simple overloads of methods using the options parameter pattern.
If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset.
⛔️ DO NOT introduce method overloads that take a subset of the parameters as well as the options parameter, except for parameters that are for client-side use only (e.g. Context, timeout, etc).
✅ DO use the options parameter type, if it exists, for all *WithResponse methods. If no options parameter type exists, do not create one solely for the *WithResponse method.
✅ DO place all options types in a root-level models package, to prevent too many root-level packages and to make use of the existing models package used by other model types.
✅ DO design options types with the same design guidance as given below for model class types, namely fluent setters for optional arguments, using the standard JavaBean naming convention of get*, set*, and is*. Additionally, there may be constructor overloads for each combination of required arguments.
✔️ YOU MAY introduce constructor overloads for each combination of required arguments (in a similar manner to required properties on model types).

Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param filePath The path to the folder containing files to upload.
     * @return A FileDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FileDatasetVersion createDatasetWithFile(String name, String version, Path filePath) {
        if (!Files.isRegularFile(filePath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a file: " + filePath));
        }
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    }


    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }


    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }



    /**
     * Creates a dataset from a folder.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or replace.
     * @param folderPath The path to the folder containing files to upload.
     * @return A FolderDatasetVersion representing the created dataset.
     * @throws IllegalArgumentException If the provided path is not a directory.
     * @throws IOException if an I/ O error is thrown when accessing the starting file
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FolderDatasetVersion createDatasetWithFolder(String name, String version, Path folderPath)
        throws IOException {
        if (!Files.isDirectory(folderPath)) {
            throw logger
                .logExceptionAsError(new IllegalArgumentException("The provided path is not a folder: " + folderPath));
        }
        // Request a pending upload for the folder
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        // Upload all files in the directory
        Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
            // Calculate relative path from the base folder
            String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
            // Create blob client for each file
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            // Upload the file
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        // Create a FolderDatasetVersion with the container URL
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    }


    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }


    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }



```
Design Guidelines:
"""
Option Parameters
Service methods fall into two main groups when it comes to the number and complexity of parameters they accept:
Service Methods with simple inputs, simple methods for short Service Methods with complex inputs, complex methods for short
Simple methods are methods that take up to six parameters, with most of the parameters being simple primitive types. Complex methods are methods that take a larger number of parameters and typically correspond to REST APIs with complex request payloads.
Simple methods should follow standard Java best practices for parameter list and overload design.
Complex methods should introduce an option parameter to represent the request payload. Consideration can subsequently be made for providing simpler convenience overloads for the most common scenarios. This is referred to in this document as the ‘options pattern’, and is demonstrated in the code below:
public class BlobContainerClient {

    // simple service methods
    public BlobInfo uploadBlob(String blobName, byte[] content);
    public Response<BlobInfo> uploadBlobWithResponse(String blobName, byte[] content, Context context);

    // complex service methods, note the introduction of the 'CreateBlobOptions' type
    public BlobInfo createBlob(CreateBlobOptions options);
    public Response<BlobInfo> createBlobWithResponse(CreateBlobOptions options, Context context);

    // convenience overload[s]
    public BlobInfo createBlob(String blobName);
}

@Fluent
public class CreateBlobOptions {
    private String blobName;
    private PublicAccessType access;
    private Map<String, String> metadata;

    // Constructor enforces the requirement that blobName is always set
    public CreateBlobOptions(String blobName) {
        this.blobName = blobName;
    }

    public String getBlobName() {
        return blobName;
    }

    public CreateBlobOptions setAccess(PublicAccessType access) {
        this.access = access;
        return this;
    }

    public PublicAccessType getAccess() {
        return access;
    }

    public CreateBlobOptions setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }
}
✅ DO name the options type after the name of the service method it is used for, such that the type is named <operation>Options. For example, above the method was createBlob, and so the options type was named CreateBlobOptions.
✅ DO use the options parameter pattern for complex service methods.
✔️ YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future.
✔️ YOU MAY add simple overloads of methods using the options parameter pattern.
If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset.
⛔️ DO NOT introduce method overloads that take a subset of the parameters as well as the options parameter, except for parameters that are for client-side use only (e.g. Context, timeout, etc).
✅ DO use the options parameter type, if it exists, for all *WithResponse methods. If no options parameter type exists, do not create one solely for the *WithResponse method.
✅ DO place all options types in a root-level models package, to prevent too many root-level packages and to make use of the existing models package used by other model types.
✅ DO design options types with the same design guidance as given below for model class types, namely fluent setters for optional arguments, using the standard JavaBean naming convention of get*, set*, and is*. Additionally, there may be constructor overloads for each combination of required arguments.
✔️ YOU MAY introduce constructor overloads for each combination of required arguments (in a similar manner to required properties on model types).

Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }



    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return represents the response for a pending upload request.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public PendingUploadResponse pendingUpload(String name, String version, PendingUploadRequest pendingUploadRequest) {
        // Generated convenience method for pendingUploadWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return pendingUploadWithResponse(name, version, BinaryData.fromObject(pendingUploadRequest), requestOptions)
            .getValue()
            .toObject(PendingUploadResponse.class);
    }


    /**
     * Start a new or get an existing pending upload of a dataset for a specific version.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     pendingUploadId: String (Optional)
     *     connectionName: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     *     pendingUploadId: String (Required)
     *     version: String (Optional)
     *     pendingUploadType: String(None/BlobReference) (Required)
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param pendingUploadRequest The pending upload request parameters.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return represents the response for a pending upload request along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> pendingUploadWithResponse(String name, String version, BinaryData pendingUploadRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.pendingUploadWithResponse(name, version, pendingUploadRequest, requestOptions);
    }



```
Design Guidelines:
"""
Option Parameters
Service methods fall into two main groups when it comes to the number and complexity of parameters they accept:
Service Methods with simple inputs, simple methods for short Service Methods with complex inputs, complex methods for short
Simple methods are methods that take up to six parameters, with most of the parameters being simple primitive types. Complex methods are methods that take a larger number of parameters and typically correspond to REST APIs with complex request payloads.
Simple methods should follow standard Java best practices for parameter list and overload design.
Complex methods should introduce an option parameter to represent the request payload. Consideration can subsequently be made for providing simpler convenience overloads for the most common scenarios. This is referred to in this document as the ‘options pattern’, and is demonstrated in the code below:
public class BlobContainerClient {

    // simple service methods
    public BlobInfo uploadBlob(String blobName, byte[] content);
    public Response<BlobInfo> uploadBlobWithResponse(String blobName, byte[] content, Context context);

    // complex service methods, note the introduction of the 'CreateBlobOptions' type
    public BlobInfo createBlob(CreateBlobOptions options);
    public Response<BlobInfo> createBlobWithResponse(CreateBlobOptions options, Context context);

    // convenience overload[s]
    public BlobInfo createBlob(String blobName);
}

@Fluent
public class CreateBlobOptions {
    private String blobName;
    private PublicAccessType access;
    private Map<String, String> metadata;

    // Constructor enforces the requirement that blobName is always set
    public CreateBlobOptions(String blobName) {
        this.blobName = blobName;
    }

    public String getBlobName() {
        return blobName;
    }

    public CreateBlobOptions setAccess(PublicAccessType access) {
        this.access = access;
        return this;
    }

    public PublicAccessType getAccess() {
        return access;
    }

    public CreateBlobOptions setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }
}
✅ DO name the options type after the name of the service method it is used for, such that the type is named <operation>Options. For example, above the method was createBlob, and so the options type was named CreateBlobOptions.
✅ DO use the options parameter pattern for complex service methods.
✔️ YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future.
✔️ YOU MAY add simple overloads of methods using the options parameter pattern.
If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset.
⛔️ DO NOT introduce method overloads that take a subset of the parameters as well as the options parameter, except for parameters that are for client-side use only (e.g. Context, timeout, etc).
✅ DO use the options parameter type, if it exists, for all *WithResponse methods. If no options parameter type exists, do not create one solely for the *WithResponse method.
✅ DO place all options types in a root-level models package, to prevent too many root-level packages and to make use of the existing models package used by other model types.
✅ DO design options types with the same design guidance as given below for model class types, namely fluent setters for optional arguments, using the standard JavaBean naming convention of get*, set*, and is*. Additionally, there may be constructor overloads for each combination of required arguments.
✔️ YOU MAY introduce constructor overloads for each combination of required arguments (in a similar manner to required properties on model types).

Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }



    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return datasetVersion Definition.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public DatasetVersion createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion) {
        // Generated convenience method for createOrUpdateDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, true);
        BinaryData datasetVersionInBinaryData = BinaryData.fromObject(datasetVersion);
        // BinaryData.fromObject() will not fire serialization, use getLength() to fire serialization.
        datasetVersionInBinaryData.getLength();
        JsonMergePatchHelper.getDatasetVersionAccessor().prepareModelForJsonMergePatch(datasetVersion, false);
        return createOrUpdateDatasetVersionWithResponse(name, version, datasetVersionInBinaryData, requestOptions)
            .getValue()
            .toObject(DatasetVersion.class);
    }
}

    /**
     * Create a new or update an existing DatasetVersion with the given version id.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     type: String(uri_file/uri_folder) (Required)
     *     dataUri: String (Optional, Required on create)
     *     isReference: Boolean (Optional)
     *     connectionName: String (Optional)
     *     id: String (Optional)
     *     name: String (Required)
     *     version: String (Required)
     *     description: String (Optional)
     *     tags (Optional): {
     *         String: String (Required)
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to create or update.
     * @param datasetVersion The DatasetVersion to create or update.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return datasetVersion Definition along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> createOrUpdateDatasetVersionWithResponse(String name, String version,
        BinaryData datasetVersion, RequestOptions requestOptions) {
        return this.serviceClient.createOrUpdateDatasetVersionWithResponse(name, version, datasetVersion,
            requestOptions);
    }



```
Design Guidelines:
"""
Option Parameters
Service methods fall into two main groups when it comes to the number and complexity of parameters they accept:
Service Methods with simple inputs, simple methods for short Service Methods with complex inputs, complex methods for short
Simple methods are methods that take up to six parameters, with most of the parameters being simple primitive types. Complex methods are methods that take a larger number of parameters and typically correspond to REST APIs with complex request payloads.
Simple methods should follow standard Java best practices for parameter list and overload design.
Complex methods should introduce an option parameter to represent the request payload. Consideration can subsequently be made for providing simpler convenience overloads for the most common scenarios. This is referred to in this document as the ‘options pattern’, and is demonstrated in the code below:
public class BlobContainerClient {

    // simple service methods
    public BlobInfo uploadBlob(String blobName, byte[] content);
    public Response<BlobInfo> uploadBlobWithResponse(String blobName, byte[] content, Context context);

    // complex service methods, note the introduction of the 'CreateBlobOptions' type
    public BlobInfo createBlob(CreateBlobOptions options);
    public Response<BlobInfo> createBlobWithResponse(CreateBlobOptions options, Context context);

    // convenience overload[s]
    public BlobInfo createBlob(String blobName);
}

@Fluent
public class CreateBlobOptions {
    private String blobName;
    private PublicAccessType access;
    private Map<String, String> metadata;

    // Constructor enforces the requirement that blobName is always set
    public CreateBlobOptions(String blobName) {
        this.blobName = blobName;
    }

    public String getBlobName() {
        return blobName;
    }

    public CreateBlobOptions setAccess(PublicAccessType access) {
        this.access = access;
        return this;
    }

    public PublicAccessType getAccess() {
        return access;
    }

    public CreateBlobOptions setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }
}
✅ DO name the options type after the name of the service method it is used for, such that the type is named <operation>Options. For example, above the method was createBlob, and so the options type was named CreateBlobOptions.
✅ DO use the options parameter pattern for complex service methods.
✔️ YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future.
✔️ YOU MAY add simple overloads of methods using the options parameter pattern.
If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset.
⛔️ DO NOT introduce method overloads that take a subset of the parameters as well as the options parameter, except for parameters that are for client-side use only (e.g. Context, timeout, etc).
✅ DO use the options parameter type, if it exists, for all *WithResponse methods. If no options parameter type exists, do not create one solely for the *WithResponse method.
✅ DO place all options types in a root-level models package, to prevent too many root-level packages and to make use of the existing models package used by other model types.
✅ DO design options types with the same design guidance as given below for model class types, namely fluent setters for optional arguments, using the standard JavaBean naming convention of get*, set*, and is*. Additionally, there may be constructor overloads for each combination of required arguments.
✔️ YOU MAY introduce constructor overloads for each combination of required arguments (in a similar manner to required properties on model types).

Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public void deleteDatasetVersion(String name, String version) {
        // Generated convenience method for deleteDatasetVersionWithResponse
        RequestOptions requestOptions = new RequestOptions();
        deleteDatasetVersionWithResponse(name, version, requestOptions).getValue();
    }


    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }



    /**
     * Delete the specific version of the DatasetVersion.
     *
     * @param name The name of the resource.
     * @param version The version of the DatasetVersion to delete.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Void> deleteDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.deleteDatasetVersionWithResponse(name, version, requestOptions);
    }



```
Design Guidelines:
"""
Option Parameters
Service methods fall into two main groups when it comes to the number and complexity of parameters they accept:
Service Methods with simple inputs, simple methods for short Service Methods with complex inputs, complex methods for short
Simple methods are methods that take up to six parameters, with most of the parameters being simple primitive types. Complex methods are methods that take a larger number of parameters and typically correspond to REST APIs with complex request payloads.
Simple methods should follow standard Java best practices for parameter list and overload design.
Complex methods should introduce an option parameter to represent the request payload. Consideration can subsequently be made for providing simpler convenience overloads for the most common scenarios. This is referred to in this document as the ‘options pattern’, and is demonstrated in the code below:
public class BlobContainerClient {

    // simple service methods
    public BlobInfo uploadBlob(String blobName, byte[] content);
    public Response<BlobInfo> uploadBlobWithResponse(String blobName, byte[] content, Context context);

    // complex service methods, note the introduction of the 'CreateBlobOptions' type
    public BlobInfo createBlob(CreateBlobOptions options);
    public Response<BlobInfo> createBlobWithResponse(CreateBlobOptions options, Context context);

    // convenience overload[s]
    public BlobInfo createBlob(String blobName);
}

@Fluent
public class CreateBlobOptions {
    private String blobName;
    private PublicAccessType access;
    private Map<String, String> metadata;

    // Constructor enforces the requirement that blobName is always set
    public CreateBlobOptions(String blobName) {
        this.blobName = blobName;
    }

    public String getBlobName() {
        return blobName;
    }

    public CreateBlobOptions setAccess(PublicAccessType access) {
        this.access = access;
        return this;
    }

    public PublicAccessType getAccess() {
        return access;
    }

    public CreateBlobOptions setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }
}
✅ DO name the options type after the name of the service method it is used for, such that the type is named <operation>Options. For example, above the method was createBlob, and so the options type was named CreateBlobOptions.
✅ DO use the options parameter pattern for complex service methods.
✔️ YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future.
✔️ YOU MAY add simple overloads of methods using the options parameter pattern.
If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset.
⛔️ DO NOT introduce method overloads that take a subset of the parameters as well as the options parameter, except for parameters that are for client-side use only (e.g. Context, timeout, etc).
✅ DO use the options parameter type, if it exists, for all *WithResponse methods. If no options parameter type exists, do not create one solely for the *WithResponse method.
✅ DO place all options types in a root-level models package, to prevent too many root-level packages and to make use of the existing models package used by other model types.
✅ DO design options types with the same design guidance as given below for model class types, namely fluent setters for optional arguments, using the standard JavaBean naming convention of get*, set*, and is*. Additionally, there may be constructor overloads for each combination of required arguments.
✔️ YOU MAY introduce constructor overloads for each combination of required arguments (in a similar manner to required properties on model types).

Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------


================================================================================
Prompt 2: Convenience Wrapper Generation
================================================================================

Context: The following Java SDK methods were flagged as potential candidates for generating convenience wrappers. The accompanying design guidelines outline desired principles for improving developer experience.

Your task:
Your goal is to think like an SDK designer, not a refactorer.
Analyse the methods and guidelines to identify high-level developer goals or workflows that are currently too low-level or fragmented.

Follow these steps:
1. Understand developer intent:
- What real-world task or developer workflow does this SDK enable?
- What steps would a developer typically need to perform manually?
2. Identify friction points:
- Are there repetitive setup steps, parameter redundancies, or multi-call workflows that could be hidden or automated?
3. Design potential convenience wrappers that:
- Represent meaningful user tasks.
- Eliminate multiple low-level method calls or configuration steps.
- Provide sensible defaults or intelligent handling for common cases.
4. Reject shallow wrappers.
- Do NOT propose wrappers that only merge 2-3 existing methods, unless they significantly improve clarity or hide complex logic.
5.  Return the generated wrapper methods, along with comments stating which methods were wrapped, and the reason for wrapping.

Output format:
/**
 * {Brief JavaDoc summary of code.}
 */
public void exampleWrapper() {
    /*
      Combined Methods: methodOne, methodTwo, etc.
      Reason: Explain why this wrapper improves developer experience
    */
    // Code here
}


Extra Notes:
- Do NOT create any classes. Your output code should only be wrapper methods.
- Do NOT include any extra commentary, aside from that in the wrapper method comments.
- Make sure that the 'Combined Methods' and 'Reason' comments are in block comments inside of the method, NOT in the Javadocs comment.
- Preserve existing functionality of the combined methods.
- Quality over quantity. Avoid creating wrapper methods for the sake of it. All wrappers must be justified
- Output the code as raw text. Do NOT put it in a code block with backticks

Methods:
```

    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }



    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the SAS credential to access the storage account associated with a Dataset version.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public AssetCredentialResult getCredentials(String name, String version) {
        // Generated convenience method for getCredentialsWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getCredentialsWithResponse(name, version, requestOptions).getValue()
            .toObject(AssetCredentialResult.class);
    }


    /**
     * Get the SAS credential to access the storage account associated with a Dataset version.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     blobReference (Required): {
     *         blobUri: String (Required)
     *         storageAccountArmId: String (Required)
     *         credential (Required): {
     *             sasUri: String (Required)
     *             type: String (Required)
     *         }
     *     }
     * }
     * }
     * </pre>
     *
     * @param name The name of the resource.
     * @param version The specific version id of the DatasetVersion to operate on.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the SAS credential to access the storage account associated with a Dataset version along with
     * {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getCredentialsWithResponse(String name, String version, RequestOptions requestOptions) {
        return this.serviceClient.getCredentialsWithResponse(name, version, requestOptions);
    }



```
Design Guidelines:
"""
Option Parameters
Service methods fall into two main groups when it comes to the number and complexity of parameters they accept:
Service Methods with simple inputs, simple methods for short Service Methods with complex inputs, complex methods for short
Simple methods are methods that take up to six parameters, with most of the parameters being simple primitive types. Complex methods are methods that take a larger number of parameters and typically correspond to REST APIs with complex request payloads.
Simple methods should follow standard Java best practices for parameter list and overload design.
Complex methods should introduce an option parameter to represent the request payload. Consideration can subsequently be made for providing simpler convenience overloads for the most common scenarios. This is referred to in this document as the ‘options pattern’, and is demonstrated in the code below:
public class BlobContainerClient {

    // simple service methods
    public BlobInfo uploadBlob(String blobName, byte[] content);
    public Response<BlobInfo> uploadBlobWithResponse(String blobName, byte[] content, Context context);

    // complex service methods, note the introduction of the 'CreateBlobOptions' type
    public BlobInfo createBlob(CreateBlobOptions options);
    public Response<BlobInfo> createBlobWithResponse(CreateBlobOptions options, Context context);

    // convenience overload[s]
    public BlobInfo createBlob(String blobName);
}

@Fluent
public class CreateBlobOptions {
    private String blobName;
    private PublicAccessType access;
    private Map<String, String> metadata;

    // Constructor enforces the requirement that blobName is always set
    public CreateBlobOptions(String blobName) {
        this.blobName = blobName;
    }

    public String getBlobName() {
        return blobName;
    }

    public CreateBlobOptions setAccess(PublicAccessType access) {
        this.access = access;
        return this;
    }

    public PublicAccessType getAccess() {
        return access;
    }

    public CreateBlobOptions setMetadata(Map<String, String> metadata) {
        this.metadata = metadata;
        return this;
    }

    public Map<String, String> getMetadata() {
        return metadata;
    }
}
✅ DO name the options type after the name of the service method it is used for, such that the type is named <operation>Options. For example, above the method was createBlob, and so the options type was named CreateBlobOptions.
✅ DO use the options parameter pattern for complex service methods.
✔️ YOU MAY use the options parameter pattern for simple service methods that you expect to grow in the future.
✔️ YOU MAY add simple overloads of methods using the options parameter pattern.
If in common scenarios, users are likely to pass just a small subset of what the options parameter represents, consider adding an overload with a parameter list representing just this subset.
⛔️ DO NOT introduce method overloads that take a subset of the parameters as well as the options parameter, except for parameters that are for client-side use only (e.g. Context, timeout, etc).
✅ DO use the options parameter type, if it exists, for all *WithResponse methods. If no options parameter type exists, do not create one solely for the *WithResponse method.
✅ DO place all options types in a root-level models package, to prevent too many root-level packages and to make use of the existing models package used by other model types.
✅ DO design options types with the same design guidance as given below for model class types, namely fluent setters for optional arguments, using the standard JavaBean naming convention of get*, set*, and is*. Additionally, there may be constructor overloads for each combination of required arguments.
✔️ YOU MAY introduce constructor overloads for each combination of required arguments (in a similar manner to required properties on model types).

Service Methods
Service methods are methods that invoke operations on a service. They are commonly found on classes suffixed with Client, but can also be found on other resource classes that are vended by a client.
⛔️ DO NOT use the suffix Async in methods that do operations asynchronously. Let the fact the user has an instance of an ‘async client’ provide this context.
✅ DO prefer the use of the following terms for CRUD operations:
Verb Parameters Returns Comments upsert<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used in database-like services. set<noun> key, item Updated or created item Create new item or update existing item. Verb is primarily used for dictionary-like properties of a service. create<noun> key, item Created item Create new item. Fails if item already exists. update<noun> key, partial item Updated item Fails if item doesn’t exist. replace<noun> key, item Replace existing item Completely replaces an existing item. Fails if the item doesn’t exist. delete<noun> key Deleted item, or null Delete an existing item. Will succeed even if item didn’t exist. Deleted item may be returned, if service supports it. add<noun> index, item Added item Add item to a collection. Item will be added last, or into the index position specified. get<noun> key Item Will return null if item doesn’t exist. list<noun> Items Return list of items. Returns empty list if no items exist. <noun>Exists key boolean Return true if the item exists.
☑️ YOU SHOULD remain flexible and use names best suited for developer experience. Don’t let the naming rules result in non-idiomatic naming patterns. For example, Java developers prefer list operations over getAll operations.
One of the Azure Core types is com.azure.core.util.Context, which acts as an append-only key-value map, and which by default is empty. The Context allows end users of the API to modify the outgoing requests to Azure on a per-method call basis, for example to enable distributed tracing.
✅ DO provide an overload method that takes a com.azure.core.util.Context argument for each service operation in sync clients only. The Context argument must be the last argument into the service method (except where varargs are used). If a service method has multiple overloads, only the ‘maximal’ overloads need to have the Context argument. A maximal overload is one that has a full set of arguments. It may not be necessary to offer a ‘Context overload’ in all cases. We prefer a minimal API surface, but Context must always be supported.
getFoo()
getFoo(x)
getFoo(x, y)
getFoo(x, y, z) // maximal overload
getFoo(a)       // maximal overload

// this will result in the following two methods being required
// (replacing the two maximal overloads above)
getFoo(x, y, z, Context)
getFoo(a, Context)
⛔️ DO NOT include overloads that take Context in async clients. Async clients use the subscriber context built into Reactor Flux and Mono APIs.

Naming Patterns
Using a consistent set of naming patterns across all client libraries will ensure a consistent and more intuitive developer experience. This section outlines good practices for naming that must be followed by all client libraries.
✅ DO prefer succinctness over verbosity in method and class names, except when readability is impacted. A few examples include:
A class may want to return an identifier to a user. There is no additional value in the fully-qualified getIdentifier() compared with the shorter and equally-descriptive getId(). A method called getName() is short, but may leave some doubt in the users mind about which name is being represented. Instead, naming this method getLinkName() will remove all doubt from the users mind, and without substantial additional verbosity. Similarly, in the case of getId() above, always choose to specify the identifier name if there is any likelihood of confusion about which identifier is being referenced. For example, use getTenantId() rather than getId(), unless it is completely unambiguous as to which identifier is being referenced.
⛔️ DO NOT fully uppercase acronyms. APIs must take the form of getHttpConnection() or getUrlName() rather than getHTTPConnection() or getURLName().
✅ DO use service-specific acronyms sparingly in API. Whereas most users will accept a method including Http or Url in the name, most users will not know what Sas or Cpk mean. Where possible (without breaking the succinctness over verbosity requirement above), expansion of acronyms, or at the very least sufficient documentation at class and method levels to describe the acronym, must be considered.
✅ DO use the correct naming for ‘host’ vs ‘hostname’. ‘hostname’ is the host name without any port number, whereas ‘host’ is the hostname with the port number.
⛔️ DO NOT use camel case on words that are commonly accepted in their combined form. For example, ‘hostname’ should be spelt as hostname rather than hostName, and ‘username’ should be spelt as username rather than userName.
⛔️ DO NOT name interface types with an ‘I’ prefix, e.g. ISearchClient. Instead, do not have any prefix for an interface, preferring SearchClient as the name for the interface type in this case.

Authentication
Azure services use a variety of different authentication schemes to allow clients to access the service. Conceptually, there are two entities responsible in this process: a credential and an authentication policy. Credentials provide confidential authentication data. Authentication policies use the data provided by a credential to authenticate requests to the service.
Primarily, all Azure services should support Azure Active Directory OAuth token authentication, and all clients of services that support Azure Active Directory OAuth token authentication must support authenticating requests in this manner.
✅ DO provide service client fluent builder APIs that accepts an instance of the appropriate azure-core credential abstraction, namely TokenCredential, BasicAuthenticationCredential, or AzureKeyCredential.
⛔️ DO NOT persist, cache, or reuse tokens beyond the validity period of the given token. If any caching is implemented, the token credential must be given the opportunity to refresh before it expires.
✅ DO use authentication policy implementations from the Azure Core library where available.
✅ DO reserve the API surface needed for TokenCredential authentication, in the rare case that a service does not yet support Azure Active Directory authentication.
In addition to Azure Active Directory OAuth, services may provide custom authentication schemes. In this case the following guidelines apply.
✅ DO support all authentication schemes that the service supports.
✅ DO define a public custom credential type which enables clients to authenticate requests using the custom scheme.
⚠️ YOU SHOULD NOT define custom credential types extending or implementing the TokenCredential abstraction from Azure Core. This is especially true in type safe languages where extending or implementing this abstraction would break the type safety of other service clients, allowing users to instantiate them with the custom credential of the wrong service.
✅ DO define custom credential types in the same namespace and package as the client, or in a service group namespace and shared package, not in Azure Core or Azure Identity.
⛔️ DO NOT take compile-scope dependency on azure-identity library.
✅ DO prepend custom credential type names with the service name or service group name to provide clear context to its intended scope and usage.
✅ DO append Credential to the end of the custom credential type name. Note this must be singular not plural.
✅ DO define a constructor or factory for the custom credential type which takes in ALL data needed for the custom authentication protocol.
✅ DO define an update method which accepts all mutable credential data, and updates the credential in an atomic, thread safe manner.
⛔️ DO NOT define public settable properties or fields which allow users to update the authentication data directly in a non-atomic manner.
⚠️ YOU SHOULD NOT define public properties or fields which allow users to access the authentication data directly. They are most often not needed by end users, and are difficult to use in a thread safe manner. In the case that exposing the authentication data is necessary, all the data needed to authenticate requests should be returned from a single API which guarantees the data returned is in a consistent state.
✅ DO provide service client constructors or factories that accept all supported credential types.
Client libraries may support providing credential data via a connection string ONLY IF the service provides a connection string to users via the portal or other tooling. Connection strings are generally good for getting started as they are easily integrated into an application by copy/paste from the portal. However, connection strings are considered a lesser form of authentication because the credentials cannot be rotated within a running process.
⛔️ DO NOT support constructing a service client with a connection string unless such connection string is available within the Azure portal or Azure CLI.

Return Types
Requests to the service fall into two basic groups: methods that make a single logical request, and methods that make a deterministic sequence of requests. An example of a single logical request is a request that may be retried inside the operation. An example of a deterministic sequence of requests is a paged operation.
The logical entity is a protocol neutral representation of a response. The logical entity may combine data from headers, body, and the status line. For example, you may expose an ETag header as a property on the logical entity. Response<T> is the ‘complete response’. It contains HTTP headers, status code, and the T object (a deserialized object created from the response body). The T object would be the ‘logical entity’.
✅ DO return the logical entity (i.e. the T) for all synchronous service methods.
✅ DO return the logical entity (i.e. the T) wrapped inside a Mono for all asynchronous service methods that make network requests.
Return Response<T> on the maximal overload for a service method with WithResponse appended to the name. For example:
Foo foo = client.getFoo(a);
Foo foo = client.getFoo(a, b);
Foo foo = client.getFoo(a, b, c, context); // This is the maximal overload, so it is replaced with the 'withResponse' 'overload' below
Response<Foo> response = client.getFooWithResponse(a, b, c, context);
For methods that combine multiple requests into a single call:
⛔️ DO NOT return headers and other per-request metadata unless it’s obvious which specific HTTP request the methods return value corresponds to.
✅ DO provide enough information in failure cases for a developer to take appropriate corrective action, including a message describing what went wrong and details on the corrective actions to take.


"""

--------------------------------------------------------------------------------

Step 2 Output: Generated Convenience Wrapper

--------------------------------------------------------------------------------
/**
 * Retrieves all versions of the specified dataset, or just the latest version if requested.
 * Simplifies the workflow of listing dataset versions by providing a single entry point for both common scenarios.
 *
 * @param name The name of the dataset resource.
 * @param latestOnly If true, returns only the latest version of each dataset; if false, returns all versions.
 * @return Paged collection of DatasetVersion items as a {@link PagedIterable}.
 */
public PagedIterable<DatasetVersion> listDatasetVersions(String name, boolean latestOnly) {
    /*
      Combined Methods: listDatasetVersions, listLatestDatasetVersions
      Reason: Developers often want either all versions or just the latest version of a dataset. This wrapper provides a single, intent-driven entry point, reducing the need for developers to discover and choose between two similar methods. It streamlines the API surface and aligns with common developer workflows.
    */
    if (latestOnly) {
        return listLatestDatasetVersions();
    } else {
        return listDatasetVersions(name);
    }
}/**
 * Retrieves a specific version of a DatasetVersion, providing sensible defaults for request options.
 * This overload streamlines the common scenario where only the resource name and version are required.
 */
public DatasetVersion getDatasetVersion(String name, String version) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Provides a streamlined overload for the common case, hiding RequestOptions boilerplate and returning the logical entity directly, as per Azure SDK guidelines.
    */
    RequestOptions requestOptions = new RequestOptions();
    return getDatasetVersionWithResponse(name, version, requestOptions).getValue().toObject(DatasetVersion.class);
}

/**
 * Retrieves a specific version of a DatasetVersion and returns the logical entity along with the full HTTP response.
 * This overload allows advanced users to specify custom request options.
 */
public Response<DatasetVersion> getDatasetVersionWithResponse(String name, String version, RequestOptions requestOptions) {
    /*
      Combined Methods: getDatasetVersionWithResponse
      Reason: Improves developer experience by returning a strongly-typed logical entity (DatasetVersion) in the Response, eliminating the need for manual deserialization from BinaryData.
    */
    Response<BinaryData> response = getDatasetVersionWithResponse(name, version, requestOptions);
    DatasetVersion datasetVersion = response.getValue().toObject(DatasetVersion.class);
    return new SimpleResponse<>(response.getRequest(), response.getStatusCode(), response.getHeaders(), datasetVersion);
}/**
 * Creates or updates a dataset version from a file or folder, automatically detecting the type and handling upload.
 *
 * <p>
 * This method simplifies dataset creation by handling both file and folder sources, managing pending upload requests,
 * uploading content, and registering the dataset version. It eliminates the need for the developer to manually check
 * file/folder types, perform multi-step upload logic, or construct request payloads.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param path The path to the file or folder to upload.
 * @return The created dataset version as either FileDatasetVersion or FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is neither a file nor a directory.
 * @throws IOException If an I/O error occurs when accessing the file system.
 */
public Object createOrUpdateDatasetVersion(String name, String version, Path path) throws IOException {
    /*
      Combined Methods: createDatasetWithFile, createDatasetWithFolder, pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper abstracts the repetitive and error-prone logic of distinguishing between file and folder uploads,
      managing pending upload requests, uploading content, and registering the dataset version. It enables a single, intent-driven
      method for the common workflow of dataset version creation from local sources, reducing boilerplate and potential for error.
    */
    if (Files.isRegularFile(path)) {
        // File upload workflow
        PendingUploadRequest body = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
        BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
        blobClient.upload(BinaryData.fromFile(path));
        RequestOptions requestOptions = new RequestOptions();
        FileDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
            .getValue()
            .toObject(FileDatasetVersion.class);
        return datasetVersion;
    } else if (Files.isDirectory(path)) {
        // Folder upload workflow
        PendingUploadRequest request = new PendingUploadRequest();
        PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
        String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
        SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
        String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
        Files.walk(path).filter(Files::isRegularFile).forEach(filePath -> {
            String relativePath = path.relativize(filePath).toString().replace('\\', '/');
            BlobClient blobClient
                = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
            blobClient.upload(BinaryData.fromFile(filePath), true);
        });
        RequestOptions requestOptions = new RequestOptions();
        FolderDatasetVersion datasetVersion = this
            .createOrUpdateDatasetVersionWithResponse(name, version,
                BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
            .getValue()
            .toObject(FolderDatasetVersion.class);
        return datasetVersion;
    } else {
        throw new IllegalArgumentException("The provided path is neither a file nor a folder: " + path);
    }
}

/**
 * Creates or updates a dataset version from a file, with sensible defaults for common scenarios.
 *
 * <p>
 * This method streamlines the process of uploading a file as a dataset version by handling pending upload requests,
 * blob upload, and dataset registration with minimal required parameters.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param filePath The path to the file to upload.
 * @return The created FileDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a file.
 */
public FileDatasetVersion createDatasetVersionFromFile(String name, String version, Path filePath) {
    /*
      Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper eliminates repetitive setup for file-based dataset version creation, providing a clear,
      intent-driven method for the most common file upload scenario.
    */
    if (!Files.isRegularFile(filePath)) {
        throw new IllegalArgumentException("The provided path is not a file: " + filePath);
    }
    PendingUploadRequest body = new PendingUploadRequest();
    PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, body);
    SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
    String blobUri = pendingUploadResponse.getBlobReference().getBlobUri();
    BlobClient blobClient = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(name).buildClient();
    blobClient.upload(BinaryData.fromFile(filePath));
    RequestOptions requestOptions = new RequestOptions();
    FileDatasetVersion datasetVersion = this
        .createOrUpdateDatasetVersionWithResponse(name, version,
            BinaryData.fromObject(new FileDatasetVersion().setDataUri(blobClient.getBlobUrl())), requestOptions)
        .getValue()
        .toObject(FileDatasetVersion.class);
    return datasetVersion;
}

/**
 * Creates or updates a dataset version from a folder, with sensible defaults for common scenarios.
 *
 * <p>
 * This method streamlines the process of uploading a folder as a dataset version by handling pending upload requests,
 * recursive file upload, and dataset registration with minimal required parameters.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to create or update.
 * @param folderPath The path to the folder to upload.
 * @return The created FolderDatasetVersion.
 * @throws IllegalArgumentException If the provided path is not a directory.
 * @throws IOException If an I/O error occurs when accessing the file system.
 */
public FolderDatasetVersion createDatasetVersionFromFolder(String name, String version, Path folderPath) throws IOException {
    /*
      Combined Methods: pendingUpload, createOrUpdateDatasetVersionWithResponse
      Reason: This wrapper eliminates repetitive setup for folder-based dataset version creation, providing a clear,
      intent-driven method for the most common folder upload scenario.
    */
    if (!Files.isDirectory(folderPath)) {
        throw new IllegalArgumentException("The provided path is not a folder: " + folderPath);
    }
    PendingUploadRequest request = new PendingUploadRequest();
    PendingUploadResponse pendingUploadResponse = this.pendingUpload(name, version, request);
    String blobContainerUri = pendingUploadResponse.getBlobReference().getBlobUri();
    SasCredential credential = pendingUploadResponse.getBlobReference().getCredential();
    String containerUrl = blobContainerUri.substring(0, blobContainerUri.lastIndexOf('/'));
    Files.walk(folderPath).filter(Files::isRegularFile).forEach(filePath -> {
        String relativePath = folderPath.relativize(filePath).toString().replace('\\', '/');
        BlobClient blobClient
            = new BlobClientBuilder().endpoint(credential.getSasUri()).blobName(relativePath).buildClient();
        blobClient.upload(BinaryData.fromFile(filePath), true);
    });
    RequestOptions requestOptions = new RequestOptions();
    FolderDatasetVersion datasetVersion = this
        .createOrUpdateDatasetVersionWithResponse(name, version,
            BinaryData.fromObject(new FolderDatasetVersion().setDataUri(containerUrl)), requestOptions)
        .getValue()
        .toObject(FolderDatasetVersion.class);
    return datasetVersion;
}/**
 * Starts a new pending upload or retrieves an existing one for a dataset version, using only required parameters and sensible defaults.
 * <p>
 * This method simplifies the process of initiating a pending upload for the most common scenario,
 * requiring only the dataset name, version, and the required pending upload type.
 * Optional parameters such as pendingUploadId and connectionName are omitted for simplicity.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @return The response for the pending upload request.
 */
public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType) {
    /*
      Combined Methods: pendingUpload
      Reason: Provides a streamlined overload for the most common workflow, reducing boilerplate by
      allowing the developer to specify only the required fields. This eliminates the need to manually
      construct a PendingUploadRequest for the simple case, improving clarity and reducing friction.
    */
    PendingUploadRequest request = new PendingUploadRequest();
    request.setPendingUploadType(pendingUploadType);
    return pendingUpload(name, version, request);
}

/**
 * Starts a new pending upload or retrieves an existing one for a dataset version, allowing the caller to specify a connection name.
 * <p>
 * This method simplifies the process of initiating a pending upload for scenarios where a connection name is commonly used,
 * requiring only the dataset name, version, pending upload type, and connection name.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @param connectionName The name of the connection to use for the upload.
 * @return The response for the pending upload request.
 */
public PendingUploadResponse startPendingUpload(String name, String version, String pendingUploadType, String connectionName) {
    /*
      Combined Methods: pendingUpload
      Reason: Reduces boilerplate for a common scenario where a connection name is specified, letting developers avoid manual construction of the request object.
    */
    PendingUploadRequest request = new PendingUploadRequest();
    request.setPendingUploadType(pendingUploadType);
    request.setConnectionName(connectionName);
    return pendingUpload(name, version, request);
}

/**
 * Starts or retrieves a pending upload for a dataset version, specifying all commonly-used parameters.
 * <p>
 * This method provides a streamlined overload for the scenario where a pending upload ID is reused (e.g., for resuming uploads),
 * in addition to specifying the connection name and upload type.
 * </p>
 *
 * @param name The name of the dataset resource.
 * @param version The specific version id of the DatasetVersion to operate on.
 * @param pendingUploadType The type of pending upload (e.g., "BlobReference").
 * @param connectionName The name of the connection to use for the upload.
 * @param pendingUploadId The ID of an existing pending upload to resume, or null to start a new one.
 * @return The response for the pending upload request.
 */
public PendingUploadResponse startOrResumePendingUpload(String name, String version, String pendingUploadType, String connectionName, String pendingUploadId) {
    /*
      Combined Methods: pendingUpload
      Reason: Provides a clear, intent-driven method for resuming or starting uploads, reducing manual request object setup and clarifying the workflow for resuming uploads.
    */
    PendingUploadRequest request = new PendingUploadRequest();
    request.setPendingUploadType(pendingUploadType);
    request.setConnectionName(connectionName);
    request.setPendingUploadId(pendingUploadId);
    return pendingUpload(name, version, request);
}/**
 * Creates or updates a DatasetVersion with the given name and version, using only the required parameters.
 * <p>
 * This overload provides a streamlined way to upsert a DatasetVersion when only the required fields are needed.
 * Optional fields (description, tags, etc.) can be set on the DatasetVersion model before passing it in.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(String name, String version, String type, String dataUri) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: Developers commonly want to quickly create or update a DatasetVersion with minimal required information.
      This wrapper reduces boilerplate by constructing the DatasetVersion model with required fields, allowing
      for a fast-path upsert scenario. Optional fields can be set by the developer on the returned object if needed.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with the given name and version, including optional description and tags.
 * <p>
 * This overload simplifies the common scenario where a developer wants to upsert a DatasetVersion and also
 * provide a description and tags, without manually constructing the DatasetVersion model.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(
    String name,
    String version,
    String type,
    String dataUri,
    String description,
    Map<String, String> tags
) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: Developers often want to specify description and tags when creating or updating a DatasetVersion.
      This wrapper reduces repetitive model construction and parameter mapping, improving clarity and usability.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(name)
        .setVersion(version)
        .setType(type)
        .setDataUri(dataUri)
        .setDescription(description)
        .setTags(tags);
    return createOrUpdateDatasetVersion(name, version, datasetVersion);
}

/**
 * Creates or updates a DatasetVersion with all available options, using a builder-style options parameter.
 * <p>
 * This overload enables future extensibility and aligns with the Azure SDK options pattern, allowing
 * developers to fluently specify only the fields they care about.
 * </p>
 */
public DatasetVersion upsertDatasetVersion(UpsertDatasetVersionOptions options) {
    /*
      Combined Methods: createOrUpdateDatasetVersion(String name, String version, DatasetVersion datasetVersion)
      Reason: This wrapper introduces an options parameter pattern for extensibility and fluent usage, reducing
      the need for multiple overloads as the DatasetVersion model evolves. It aligns with Azure SDK guidelines
      for complex inputs and future-proofs the API surface.
    */
    DatasetVersion datasetVersion = new DatasetVersion()
        .setName(options.getName())
        .setVersion(options.getVersion())
        .setType(options.getType())
        .setDataUri(options.getDataUri())
        .setIsReference(options.isReference())
        .setConnectionName(options.getConnectionName())
        .setDescription(options.getDescription())
        .setTags(options.getTags());
    return createOrUpdateDatasetVersion(options.getName(), options.getVersion(), datasetVersion);
}/**
 * Deletes all versions of a dataset with the given name.
 * <p>
 * This method finds and deletes all versions of the specified dataset, handling common error scenarios.
 * </p>
 *
 * @param name The name of the dataset whose versions are to be deleted.
 * @throws IllegalArgumentException if the name is null or empty.
 * @throws RuntimeException if any delete operation fails.
 */
public void deleteAllDatasetVersions(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Developers often want to clean up all versions of a dataset. This wrapper automates the repetitive pattern of listing all versions and deleting them one by one, handling errors and reducing boilerplate.
    */
    if (name == null || name.isEmpty()) {
        throw new IllegalArgumentException("Dataset name cannot be null or empty.");
    }
    // Assume listDatasetVersions returns a List<DatasetVersion> or similar
    List<DatasetVersion> versions = listDatasetVersions(name);
    for (DatasetVersion version : versions) {
        try {
            deleteDatasetVersion(name, version.getVersion());
        } catch (ResourceNotFoundException ex) {
            // Already deleted, skip
        } catch (Exception ex) {
            throw new RuntimeException("Failed to delete dataset version: " + version.getVersion(), ex);
        }
    }
}

/**
 * Deletes the latest version of a dataset.
 * <p>
 * This method finds the most recent version of the specified dataset and deletes it.
 * </p>
 *
 * @param name The name of the dataset.
 * @throws IllegalArgumentException if the name is null or empty.
 * @throws ResourceNotFoundException if no versions exist.
 * @throws RuntimeException if the delete operation fails.
 */
public void deleteLatestDatasetVersion(String name) {
    /*
      Combined Methods: listDatasetVersions, deleteDatasetVersion
      Reason: Deleting the latest version is a common workflow. This wrapper encapsulates the logic to find the latest version and delete it, reducing error-prone manual steps.
    */
    if (name == null || name.isEmpty()) {
        throw new IllegalArgumentException("Dataset name cannot be null or empty.");
    }
    List<DatasetVersion> versions = listDatasetVersions(name);
    if (versions.isEmpty()) {
        throw new ResourceNotFoundException("No versions found for dataset: " + name);
    }
    // Assume versions are sorted by version string or timestamp descending
    DatasetVersion latest = versions.get(0);
    deleteDatasetVersion(name, latest.getVersion());
}

/**
 * Deletes a dataset version if it exists, suppressing ResourceNotFoundException.
 * <p>
 * This method attempts to delete a dataset version, but does not throw if the version does not exist.
 * </p>
 *
 * @param name The name of the dataset.
 * @param version The version to delete.
 * @throws IllegalArgumentException if parameters are invalid.
 * @throws RuntimeException if the delete operation fails for reasons other than not found.
 */
public void deleteDatasetVersionIfExists(String name, String version) {
    /*
      Combined Methods: deleteDatasetVersion
      Reason: Developers often want idempotent deletes. This wrapper suppresses errors if the version does not exist, aligning with common "delete if exists" semantics.
    */
    try {
        deleteDatasetVersion(name, version);
    } catch (ResourceNotFoundException ex) {
        // Ignore, as the intent is to ensure deletion
    }
}/**
 * Retrieves the SAS credential URI for the storage account associated with a specific Dataset version.
 * <p>
 * This method simplifies access to the SAS URI by extracting it directly from the credential response,
 * allowing developers to quickly obtain the URI needed for storage operations without manually parsing
 * the full credential result.
 * </p>
 *
 * @param name The name of the Dataset resource.
 * @param version The version identifier of the Dataset.
 * @return The SAS URI string for accessing the storage account blob.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if the resource is in a conflict state.
 * @throws RuntimeException for other request failures.
 */
public String getDatasetVersionSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Developers commonly need just the SAS URI to access storage, not the full credential object.
      This wrapper eliminates the need for manual parsing of the AssetCredentialResult, streamlining the
      workflow for storage access and reducing boilerplate.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null
        || result.getBlobReference().getCredential() == null
        || result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("SAS URI could not be retrieved from the credential result.");
    }
    return result.getBlobReference().getCredential().getSasUri();
}

/**
 * Retrieves the storage account blob URI and its associated SAS credential for a specific Dataset version.
 * <p>
 * This method provides both the blob URI and the SAS token together, which are typically required together
 * for performing authenticated storage operations. It reduces the need for manual extraction from the
 * credential result and provides a clear, intent-driven API for storage access.
 * </p>
 *
 * @param name The name of the Dataset resource.
 * @param version The version identifier of the Dataset.
 * @return A simple pair containing the blob URI and the SAS URI.
 * @throws IllegalArgumentException if parameters fail validation.
 * @throws HttpResponseException if the request is rejected by the server.
 * @throws ClientAuthenticationException if authentication fails.
 * @throws ResourceNotFoundException if the resource is not found.
 * @throws ResourceModifiedException if the resource is in a conflict state.
 * @throws RuntimeException for other request failures.
 */
public java.util.AbstractMap.SimpleEntry<String, String> getDatasetVersionBlobAndSasUri(String name, String version) {
    /*
      Combined Methods: getCredentials
      Reason: Accessing a storage blob typically requires both the blob URI and its SAS credential.
      This wrapper provides both in a single call, reducing repetitive extraction logic and clarifying
      developer intent for common storage access scenarios.
    */
    AssetCredentialResult result = getCredentials(name, version);
    if (result == null || result.getBlobReference() == null
        || result.getBlobReference().getCredential() == null
        || result.getBlobReference().getBlobUri() == null
        || result.getBlobReference().getCredential().getSasUri() == null) {
        throw new IllegalStateException("Blob URI or SAS URI could not be retrieved from the credential result.");
    }
    return new java.util.AbstractMap.SimpleEntry<>(
        result.getBlobReference().getBlobUri(),
        result.getBlobReference().getCredential().getSasUri()
    );
}
================================================================================
